// Generated by CoffeeScript 2.3.1
(function() {
  var addEdgeToGraph, addElementsFromBindingsJSON, addElementsFromBindingsJSONGraphSON3, addInTheNeighbors, addVertToGraph, allHiddenEdgeIDs, allHiddenNodeIDs, allKeysInVerts, allObjectsInsideWithKeyValue, allObjectsInsideWithKeyValueGraphSON3, arrayFromGraphSON3List, atLeastOneInsideGraphSON3, buildTypeSelectorHTMLGraphSON3, cacheOriginalPropertyTypeGraphSON3, chunks, cloneElements, cloneSelections, cloneVertToGraph, deleteSelected, deleteSelections, detectGraphSON3Element, dropSelections, edgesInside, edgesInsideGraphSON3, expandSelections, expandSelections5, findJavaTypeForPropertyNamedGraphSON3, generateJSONBindingsForSelections, geoshapeGeometryGraphSON3ToWKT, geoshapeGraphSON3ToJava, getLabelSets, growSelections, hideSelections1, hideSelections2, hideSelections3, hideSelections4, inputGremlinCodeForIngestion, inspectNone, inspectSelections, invertSelections, javaValueExpressionGraphSON3, labelForVertex, labelForVertexGraphSON3, layoutSelectionsInCircle, objectFromGraphSON3Map, pinSelections, popupDialogForElement, popupDialogForElementGraphSON3, processResults, propertyTypesChangedGraphSON3, retrieveVerticesForIDs, scriptForGeneralIngestionFindOrCreate, selectAll, selectNeighborsToAdd, selectNone, shareGremlinCodeForIngestion, spawnAllToQuikVis, spawnHidden1, spawnHidden2, spawnHidden3, spawnHidden4, spawnTheseToQuikVis, spawnToQuikVis, titleForElement, titleForElementGraphSON3, typeStringForGraphSON3, unhideSelections1, unhideSelections2, unhideSelections3, unhideSelections4, unpinSelections, userPropertiesForElement, userPropertiesForElementGraphSON3, valueFromGraphSON3, valueListFromGraphSON3, vertIDsInEdges, vertIDsInEdgesGraphSON3, verticesInside, verticesInsideGraphSON3, wktValueListFromGraphSON3, wktValueListFromValueList;

  Template.ResultsVis.rendered = function() {
    var graph, j, len, node, oldLoc, positions, ref, ve, vn;
    Session.set('graphRenderingStatus', 'Rendering...');
    Session.set('keyForNodeLabel', "null");
    Session.set('useLabelPrefix', true);
    window.setUpVis();
    Session.set('graphRenderingStatus', 'Rendering...');
    graph = Session.get('graphToShow');
    Session.set('renderStartTime', moment().toDate());
    vn = new vis.DataSet(graph.nodes);
    ve = new vis.DataSet(graph.edges);
    window.visnetwork.setData({
      nodes: vn,
      edges: ve
    });
    getLabelSets();
    if (Session.get('positions')) {
      positions = Session.get('positions');
    } else {
      positions = {};
    }
    ref = graph.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = positions[node.id];
      if (oldLoc) {
        node.x = oldLoc.x;
        node.y = oldLoc.y;
        node.physics = false; // pin it
      }
    }
    return window.visnetwork.nodesHandler.body.data.nodes.update(graph.nodes);
  };

  //---------------- Helpers --------------------------
  Template.ResultsVis.helpers({
    vertexPropertyNames: function() {
      return Session.get('vertexPropertyNames');
    },
    vertexPropertyName: function() {
      return this;
    },
    vertexLabels: function() {
      if (window.visnetwork) {
        getLabelSets();
      }
      return Session.get('vertexLabelSet');
    },
    vertexLabel: function() {
      return this;
    },
    visWidth: function() {
      if (Session.get("visWidth")) {
        return Session.get("visWidth");
      } else {
        return 'auto';
      }
    },
    visHeight: function() {
      if (Session.get("visHeight")) {
        return Session.get("visHeight");
      } else {
        return '900px';
      }
    }
  });

  //----------------- Functions -----------------------
  window.determineGraphToShow = function() {
    //Switching to use global window.UsingGraphSON3 determined on web socket connect time
    //g3 = detectGraphSON3Element(Session.get 'scriptResult')
    if (window.UsingGraphSON3) {
      return determineGraphToShowGraphSON3();
    } else {
      return determineGraphToShowGraphSON1();
    }
  };

  detectGraphSON3Element = function(obj) {
    var edgeFound, vertFound;
    if (!obj[0]) {
      return false;
    }
    if (obj[0]['@value']) {
      return true;
    }
    vertFound = atLeastOneInsideGraphSON3(obj, '@type', 'g:Vertex');
    if (vertFound) {
      return true;
    }
    edgeFound = atLeastOneInsideGraphSON3(obj, '@type', 'g:Edge');
    return edgeFound;
  };

  atLeastOneInsideGraphSON3 = function(obj, key, value) {
    var answer, j, l, len, len1, okey, ref, subObj;
    if (obj[key] && (obj[key] === value)) {
      return true;
    } else {
      if ((typeof obj === 'string') || (typeof obj === 'boolean') || (typeof obj === 'number') || (typeof obj === 'symbol') || (typeof obj === 'undefined') || (obj === null)) {
        return false;
      }
      if (Array.isArray(obj)) { //its an array, recurse
        for (j = 0, len = obj.length; j < len; j++) {
          subObj = obj[j];
          answer = atLeastOneInsideGraphSON3(subObj, key, value);
          if (answer) {
            return true;
          }
        }
      } else {
        ref = Object.keys(obj);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          okey = ref[l];
          answer = atLeastOneInsideGraphSON3(obj[okey], key, value);
          if (answer) {
            return true;
          }
        }
      }
    }
    return false;
  };

  window.determineGraphToShowGraphSON1 = function() {
    var bindings, edges, missingVIDs, request, script, startTime, v, vIDsInEdges, vIDsInResults, verts;
    Session.set('graphToShow', {
      nodes: [],
      edges: []
    });
    verts = verticesInside(Session.get('scriptResult'));
    verts = _.uniq(verts, function(item) {
      return item.id;
    });
    edges = edgesInside(Session.get('scriptResult'));
    vIDsInEdges = vertIDsInEdges(edges);
    vIDsInResults = [];
    vIDsInResults = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push(v.id);
      }
      return results1;
    })();
    missingVIDs = _.difference(vIDsInEdges, vIDsInResults);
    if (missingVIDs.length === 0) {
      return setGraphToShow(verts, edges);
    }
    bindings = {
      vIDs: missingVIDs
    };
    script = 'vIDs.collect{each-> g.V(each).next()}';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, results;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            results = [];
          } else {
            results = json.result.data;
          }
          addVertsToGraphToShow(results);
          addEdgesToGraphToShow(edges);
          addVertsToGraphToShow(verts);
          return Session.set('elementsInResults', {
            vertices: verts,
            edges: edges
          });
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in Vertex Retriever', script, bindings, function(error, result) {
        addVertsToGraphToShow(result.results);
        addEdgesToGraphToShow(edges);
        addVertsToGraphToShow(verts);
        return Session.set('elementsInResults', {
          vertices: verts,
          edges: edges
        });
      });
    }
  };

  window.determineGraphToShowGraphSON3 = function() {
    var bindings, edges, missingVIDs, request, script, startTime, v, vIDsInEdges, vIDsInResults, verts;
    Session.set('graphToShow', {
      nodes: [],
      edges: []
    });
    verts = verticesInsideGraphSON3(Session.get('scriptResult'));
    verts = _.uniq(verts, function(item) {
      return item.id['@value'];
    });
    edges = edgesInsideGraphSON3(Session.get('scriptResult'));
    vIDsInEdges = vertIDsInEdgesGraphSON3(edges);
    vIDsInResults = [];
    vIDsInResults = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push(v.id['@value']);
      }
      return results1;
    })();
    missingVIDs = _.difference(vIDsInEdges, vIDsInResults);
    if (missingVIDs.length === 0) {
      return setGraphToShowGraphSON3(verts, edges);
    }
    bindings = {
      vIDs: missingVIDs
    };
    script = 'vIDs.collect{each-> g.V(each).next()}';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, gts, json, results;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            results = [];
          } else {
            results = json.result.data;
          }
          addVertsToGraphToShowGraphSON3((function() {
            var j, len, ref, results1;
            ref = results['@value'];
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              v = ref[j];
              results1.push(v['@value']);
            }
            return results1;
          })());
          addEdgesToGraphToShowGraphSON3(edges);
          addVertsToGraphToShowGraphSON3(verts);
          gts = Session.get('graphToShow');
          return Session.set('elementsInResults', gts);
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in Vertex Retriever', script, bindings, function(error, result) {
        var gts;
        addVertsToGraphToShowGraphSON3(result.results);
        addEdgesToGraphToShowGraphSON3(edges);
        addVertsToGraphToShowGraphSON3(verts);
        gts = Session.get('graphToShow');
        return Session.set('elementsInResults', gts);
      });
    }
  };

  window.addVertsToGraphToShow = function(verts) {
    var gts, nodes, v;
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, Session.get('keyForNodeLabel')),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    if (window.visnetwork) {
      window.visnetwork.nodesHandler.body.data.nodes.update(nodes);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    gts.nodes = gts.nodes.concat(nodes);
    Session.set('graphToShow', gts);
    if (gts.nodes.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.addEdgesToGraphToShow = function(edges) {
    var e, gts;
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        e = edges[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    if (window.visnetwork) {
      window.visnetwork.edgesHandler.body.data.edges.update(edges);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    //console.log 'before=',gts
    gts.edges = gts.edges.concat(edges);
    //console.log 'after=',gts
    Session.set('graphToShow', gts);
    if (gts.edges.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.setGraphToShow = function(verts, edges) {
    var e, g, keyForLabel, nodes, v;
    keyForLabel = Session.get('keyForNodeLabel');
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = verts.length; j < len; j++) {
        v = verts[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, keyForLabel),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        e = edges[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    g = {
      nodes: nodes,
      edges: edges
    };
    Session.set('graphToShow', g);
    if (g.nodes.length + g.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.addVertsToGraphToShowGraphSON3 = function(verts) {
    var gts, j, len, node, nodes, v;
    nodes = [];
    for (j = 0, len = verts.length; j < len; j++) {
      v = verts[j];
      v.type = 'vertex';
      node = {
        id: String(v.id['@value']),
        label: labelForVertexGraphSON3(v, Session.get('keyForNodeLabel')),
        allowedToMoveX: true,
        allowedToMoveY: true,
        title: titleForElementGraphSON3(v),
        element: v
      };
      nodes.push(node);
    }
    if (window.visnetwork) {
      window.visnetwork.nodesHandler.body.data.nodes.update(nodes);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    gts.nodes = gts.nodes.concat(nodes);
    Session.set('graphToShow', gts);
    if (gts.nodes.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.addEdgesToGraphToShowGraphSON3 = function(edgesData) {
    var e, edge, edges, gts, j, len;
    edges = [];
    for (j = 0, len = edgesData.length; j < len; j++) {
      e = edgesData[j];
      e.type = 'edge';
      edge = {
        id: String(e.id['@value']['relationId']),
        label: e.label,
        from: String(e.outV['@value']),
        to: String(e.inV['@value']),
        title: titleForElementGraphSON3(e),
        element: e
      };
      edges.push(edge);
    }
    if (window.visnetwork) {
      window.visnetwork.edgesHandler.body.data.edges.update(edges);
    }
    if ((Session.get('graphToShow')) === void 0) {
      Session.set('graphToShow', {
        nodes: [],
        edges: []
      });
    }
    gts = Session.get('graphToShow');
    //console.log 'before=',gts
    gts.edges = gts.edges.concat(edges);
    //console.log 'after=',gts
    Session.set('graphToShow', gts);
    if (gts.edges.length + gts.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.setGraphToShowGraphSON3 = function(verts, edgesData) {
    var e, edge, edges, g, j, keyForLabel, l, len, len1, node, nodes, v;
    keyForLabel = Session.get('keyForNodeLabel');
    nodes = [];
    for (j = 0, len = verts.length; j < len; j++) {
      v = verts[j];
      v.type = 'vertex';
      node = {
        id: String(v.id['@value']),
        label: labelForVertexGraphSON3(v, keyForLabel),
        allowedToMoveX: true,
        allowedToMoveY: true,
        title: titleForElementGraphSON3(v),
        element: v
      };
      nodes.push(node);
    }
    edges = [];
    for (l = 0, len1 = edgesData.length; l < len1; l++) {
      e = edgesData[l];
      e.type = 'edge';
      edge = {
        id: String(e.id['@value']['relationId']),
        label: e.label,
        from: String(e.outV['@value']),
        to: String(e.inV['@value']),
        title: titleForElementGraphSON3(e),
        element: e
      };
      edges.push(edge);
    }
    g = {
      nodes: nodes,
      edges: edges
    };
    Session.set('graphToShow', g);
    if (g.nodes.length + g.edges.length > 0) {
      return Session.set('graphFoundInResults', true);
    } else {
      return Session.set('graphFoundInResults', false);
    }
  };

  window.randomizeLayout = function() {
    var g, j, len, node, ref;
    g = Session.get('graphToShow');
    ref = g.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      node.x = chance.floating({
        min: 0,
        max: 100
      });
      node.y = chance.floating({
        min: 0,
        max: 100
      });
    }
    return Session.set('graphToShow', g);
  };

  verticesInside = function(obj) {
    var verts;
    verts = [];
    allObjectsInsideWithKeyValue(verts, obj, 'type', 'vertex');
    return verts;
  };

  edgesInside = function(obj) {
    var edges;
    edges = [];
    allObjectsInsideWithKeyValue(edges, obj, 'type', 'edge');
    return edges;
  };

  vertIDsInEdges = function(edges) {
    var edge, edgeVertIDs, j, l, len, len1;
    edgeVertIDs = [];
    for (j = 0, len = edges.length; j < len; j++) {
      edge = edges[j];
      edgeVertIDs.push(edge.inV);
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      edgeVertIDs.push(edge.outV);
    }
    return _.uniq(edgeVertIDs);
  };

  allObjectsInsideWithKeyValue = function(foundArray, obj, key, value) {
    var j, l, len, len1, okey, ref, subObj;
    if ((typeof obj === 'string') || (typeof obj === 'boolean') || (typeof obj === 'number') || (typeof obj === 'symbol') || (typeof obj === 'undefined') || (obj === null)) {
      return [];
    }
    if (Array.isArray(obj)) { //its an array, recurse
//its not an array, assume an object
      for (j = 0, len = obj.length; j < len; j++) {
        subObj = obj[j];
        allObjectsInsideWithKeyValue(foundArray, subObj, key, value);
      }
    } else {
      if (obj[key] && obj[key] === value) {
        foundArray.push(obj); //recurse deeper
      } else {
        ref = Object.keys(obj);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          okey = ref[l];
          allObjectsInsideWithKeyValue(foundArray, obj[okey], key, value);
        }
      }
    }
    return [];
  };

  verticesInsideGraphSON3 = function(obj) {
    var verts;
    verts = [];
    allObjectsInsideWithKeyValueGraphSON3(verts, obj, '@type', 'g:Vertex');
    return verts;
  };

  edgesInsideGraphSON3 = function(obj) {
    var edges;
    edges = [];
    allObjectsInsideWithKeyValueGraphSON3(edges, obj, '@type', 'g:Edge');
    return edges;
  };

  vertIDsInEdgesGraphSON3 = function(edges) {
    var edge, edgeVertIDs, j, l, len, len1;
    edgeVertIDs = [];
    for (j = 0, len = edges.length; j < len; j++) {
      edge = edges[j];
      edgeVertIDs.push(edge.inV['@value']);
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      edgeVertIDs.push(edge.outV['@value']);
    }
    return _.uniq(edgeVertIDs);
  };

  allObjectsInsideWithKeyValueGraphSON3 = function(foundArray, obj, key, value) {
    var j, l, len, len1, okey, ref, subObj;
    if ((typeof obj === 'string') || (typeof obj === 'boolean') || (typeof obj === 'number') || (typeof obj === 'symbol') || (typeof obj === 'undefined') || (obj === null)) {
      return [];
    }
    if (Array.isArray(obj)) { //its an array, recurse
//its not an array, assume an object
      for (j = 0, len = obj.length; j < len; j++) {
        subObj = obj[j];
        allObjectsInsideWithKeyValueGraphSON3(foundArray, subObj, key, value);
      }
    } else {
      if (obj[key] && obj[key] === value) {
        foundArray.push(obj['@value']);
      } else {
        ref = Object.keys(obj);
        for (l = 0, len1 = ref.length; l < len1; l++) {
          okey = ref[l];
          allObjectsInsideWithKeyValueGraphSON3(foundArray, obj[okey], key, value);
        }
      }
    }
    return [];
  };

  //********************* array splitter, used to be used to process batches of verts and edges due to GET length restrictions, no longer needed since moving to POST
  chunks = function(array, size) {
    var results;
    results = [];
    while (array.length) {
      results.push(array.splice(0, size));
    }
    return results;
  };

  retrieveVerticesForIDs = function(ids, callback) {
    var bindings, request, script, startTime;
    if (ids.length === 0) {
      return;
    }
    bindings = {
      vIDs: ids
    };
    script = 'vIDs.collect{each-> g.V(each).next()}';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, results;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            results = [];
          } else {
            results = json.result.data;
          }
          return callback(results);
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in Vertex Retriever', script, bindings, function(error, result) {
        return callback(result.results);
      });
    }
  };

  titleForElementGraphSON3 = function(props) {
    var html, id, j, key, len, sortedKeys, tr, userProps, value;
    if (props.type === 'edge') {
      id = props.id['@value']['relationId'];
    } else {
      id = props.id['@value'];
    }
    userProps = userPropertiesForElementGraphSON3(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:200">';
    html = html + '<tr><th>' + props.type + ': </th><th>' + id + '</th><tr>';
    html = html + '<tr><td>label: </td><td>' + props.label + '</td><tr>';
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      tr = '<tr><td>' + key + ': </td><td>' + value + '</td></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '</div>';
    return html;
  };

  titleForElement = function(props) {
    var html, j, key, len, sortedKeys, tr, userProps, value;
    //console.log props
    userProps = userPropertiesForElement(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:200">';
    html = html + '<tr><th>' + props.type + ': </th><th>' + props.id + '</th><tr>';
    html = html + '<tr><td>label: </td><td>' + props.label + '</td><tr>';
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      tr = '<tr><td>' + key + ': </td><td>' + value + '</td></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '</div>';
    return html;
  };

  popupDialogForElement = function(localElement, elementType) {
    var addPropButton, cloneButton, copyPropButton, deletePropButton, html, id, j, key, len, logButton, pastePropButton, pinItButton, props, sortedKeys, tr, userProps, value;
    props = localElement.element;
    userProps = userPropertiesForElement(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    id = props.id;
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:100%" class="propTableForElementID' + id + '" name="' + elementType + '">';
    addPropButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Add property"><span class="glyphicon glyphicon-plus element-addProperty' + id + '"></span></a>';
    if (elementType === 'vertex') {
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Vertex"><span class="clone-vertex' + id + '">Clone</span></a>';
    } else {
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Edge"><span class="clone-edge' + id + '">Clone</span></a>';
    }
    deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
    copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
    pastePropButton = '<a href="#" class="btn btn-default" title="Paste property"><span class="glyphicon glyphicon-paste element-pasteProperty' + id + '"></span></a>';
    logButton = '<a href="#" class="btn btn-default" title="console.log the element"><span class="glyphicon glyphicon-share element-log' + id + '"></span></a>';
    pinItButton = '<input type="checkbox" class="vis-options-checkbox" id="pinItCheckBoxForId' + id + '" value="' + localElement.allowedToMoveX + '" onclick="pinVertex(\'' + id + '\',this.value)"><span class="glyphicon glyphicon-pushpin"></span></a>';
    html = html + '<tr><th>Property:  </th><th>Value</th><th style="width:50">' + addPropButton + pastePropButton + logButton + '</th><tr>';
    tr = '<tr><td>id:  </td><td>' + id + '</td><td style="width:50">' + pinItButton + '</td><tr>';
    html = html + tr;
    tr = '<tr><td>label:  </td><td>' + props.label + '</td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + cloneButton + '</th></tr>';
    html = html + tr;
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><th style="width:100%" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '<button type="button" style="display: none" class="commitButtonForElementID' + id + '" onclick="updateElementProps(\'' + id + '\',\'' + elementType + '\')">Commit changes</button>';
    html = html + '</div>';
    return html;
  };

  popupDialogForElementGraphSON3 = function(localElement, elementType) {
    var addPropButton, cloneButton, copyPropButton, deletePropButton, html, id, j, key, len, logButton, pastePropButton, pinItButton, props, sortedKeys, tr, type, typeSelector, userProps, value;
    props = localElement.element;
    userProps = userPropertiesForElementGraphSON3(props);
    sortedKeys = _.sortBy(_.keys(userProps), function(e) {
      return e.toLocaleLowerCase();
    });
    if (elementType === 'vertex') {
      id = props.id['@value'];
    } else {
      id = props.id['@value']['relationId'];
    }
    html = '<div  class="vis-element-popup">';
    html = html + '<table style="width:100%" class="propTableForElementID' + id + '" name="' + elementType + '">';
    if (elementType === 'vertex') {
      addPropButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Add property"><span class="glyphicon glyphicon-plus element-addVertexPropertyGraphSON3' + id + '"></span></a>';
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Vertex"><span class="clone-vertex' + id + '">Clone</span></a>';
    } else {
      addPropButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Add property"><span class="glyphicon glyphicon-plus element-addEdgePropertyGraphSON3' + id + '"></span></a>';
      cloneButton = '<a href="#" class="btn btn-default" id="' + id + '" title="Clone this Edge"><span class="clone-edge' + id + '">Clone</span></a>';
    }
    deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
    copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
    pastePropButton = '<a href="#" class="btn btn-default" title="Paste property"><span class="glyphicon glyphicon-paste element-pasteProperty' + id + '"></span></a>';
    logButton = '<a href="#" class="btn btn-default" title="console.log the element"><span class="glyphicon glyphicon-share element-log' + id + '"></span></a>';
    pinItButton = '<input type="checkbox" class="vis-options-checkbox" id="pinItCheckBoxForId' + id + '" value="' + localElement.allowedToMoveX + '" onclick="pinVertex(\'' + id + '\',this.value)"><span class="glyphicon glyphicon-pushpin"></span></a>';
    html = html + '<tr><th>Property:  </th><th>Value</th><th style="width:50">' + addPropButton + pastePropButton + logButton + '</th><tr>';
    tr = '<tr><td>id:  </td><td>' + id + '</td><td style="width:50">' + pinItButton + '</td><tr>';
    html = html + tr;
    tr = '<tr><td>label:  </td><td>' + props.label + '</td><th style="width:50px" id="' + id + '" value="' + elementType + '" name="' + key + '">' + cloneButton + '</th></tr>';
    html = html + tr;
    for (j = 0, len = sortedKeys.length; j < len; j++) {
      key = sortedKeys[j];
      value = userProps[key];
      type = findJavaTypeForPropertyNamedGraphSON3(key, props, elementType);
      cacheOriginalPropertyTypeGraphSON3(elementType, id, key, type);
      typeSelector = buildTypeSelectorHTMLGraphSON3(id, key, type, elementType, 'disabled');
      tr = '<tr><td>' + key + ':  </td><td style="width:100%"><input style="width:100%" type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><td style="width:100%" id="' + id + '" value="' + elementType + '" name="' + key + '">' + typeSelector + deletePropButton + copyPropButton + '</td></tr>';
      html = html + tr;
    }
    html = html + '</table>';
    html = html + '<button type="button" style="display: none" class="commitButtonForElementID' + id + '" onclick="updateElementPropsGraphSON3(\'' + id + '\',\'' + elementType + '\')">Commit changes</button>';
    html = html + '</div>';
    return html;
  };

  cacheOriginalPropertyTypeGraphSON3 = function(elementType, id, key, type) {
    if (!window.ElementPropertyTypeChangeCacheForGraphSON3) {
      window.ElementPropertyTypeChangeCacheForGraphSON3 = {
        vertex: {},
        edge: {}
      };
    }
    if (!window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]) {
      window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id] = {
        originalTypes: {},
        newTypes: {}
      };
    }
    return window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['originalTypes'][key] = type;
  };

  propertyTypesChangedGraphSON3 = function(elementType, id) {
    var changedTypes, j, key, len, newTypeKeys, newTypes, origType;
    if (window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['newTypes'] === {}) {
      return [];
    }
    changedTypes = {};
    newTypes = window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['newTypes'];
    newTypeKeys = Object.keys(newTypes);
    for (j = 0, len = newTypeKeys.length; j < len; j++) {
      key = newTypeKeys[j];
      origType = window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['originalTypes'][key];
      if (origType !== newTypes[key]) {
        changedTypes[key] = newTypes[key];
      }
    }
    return changedTypes;
  };

  window.currentPropertyTypesGraphSON3 = function(elementType, id) {
    var currentTypes, j, key, len, ref;
    currentTypes = _.clone(window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['originalTypes']);
    ref = _.keys(window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['newTypes']);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      currentTypes[key] = window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['newTypes'][key];
    }
    return currentTypes;
  };

  findJavaTypeForPropertyNamedGraphSON3 = function(propName, element, elementType) {
    var gtype, propVal, type;
    if (elementType === 'vertex') {
      propVal = element.properties[propName][0]['@value']['value'];
    } else {
      propVal = element.properties[propName]['@value']['value'];
    }
    if (propVal['@type']) {
      gtype = propVal['@type'];
      if (gtype === "janusgraph:Geoshape") {
        type = "Geoshape";
      } else {
        if (gtype.slice(0, 2) === "gx") {
          type = gtype.slice(3);
        } else {
          type = gtype.slice(2);
        }
      }
    } else {
      type = 'Undef';
      if (typeof propVal === 'string') {
        type = 'String';
      }
      if (typeof propVal === 'boolean') {
        type = 'Boolean';
      }
      console.log(typeof propVal, type);
    }
    return type;
  };

  buildTypeSelectorHTMLGraphSON3 = function(id, key, type, elementType, disabled) {
    var html, j, len, option, ref, selected, val, valueLabelMap;
    valueLabelMap = {
      String: 'String',
      Char: 'Char',
      Boolean: 'Bool',
      Byte: 'Byte',
      Int32: 'Int32',
      Int64: 'Int64',
      Float: 'Float',
      Double: 'Double',
      Date: 'Date',
      Geoshape: 'Shape',
      UUID: 'UUID',
      Class: 'Class'
    };
    html = '<select class="typeSelectorFor' + id + '" ' + disabled + ' onchange="$(\'.commitButtonForElementID' + id + '\').show();window.changePropertyTypeGraphSON3(\'' + elementType + '\',\'' + id + '\',\'' + key + '\',this.value)"   style="width:70px" >';
    ref = Object.keys(valueLabelMap);
    for (j = 0, len = ref.length; j < len; j++) {
      val = ref[j];
      selected = '';
      if (type === val) {
        selected = 'selected';
      }
      option = '<option ' + selected + ' value="' + val + '">' + valueLabelMap[val] + '</option>';
      html = html + option;
    }
    html = html + '</select>';
    return html;
  };

  window.turnOffTypeSelectorsForID = function(id) {
    return $('.typeSelectorFor' + id).attr('disabled', true);
  };

  window.changePropertyTypeGraphSON3 = function(elementType, id, key, newType) {
    var prop, visElement;
    window.ElementPropertyTypeChangeCacheForGraphSON3[elementType][id]['newTypes'][key] = newType;
    if (elementType === 'vertex') {
      visElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
      if (!visElement.element.properties) {
        visElement.element['properties'] = {};
      }
      if (!visElement.element.properties[key]) {
        visElement.element.properties[key] = [
          {
            "@type": "g:VertexProperty",
            "@value": {
              "value": {
                "@type": typeStringForGraphSON3(newType)
              }
            }
          }
        ];
      }
      prop = visElement.element.properties[key][0]['@value'];
    } else {
      visElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
      if (!visElement.element.properties) {
        visElement.element['properties'] = {};
      }
      if (!visElement.element.properties[key]) {
        visElement.element.properties[key] = {
          "@type": "g:Property",
          "@value": {
            "value": {
              "@type": typeStringForGraphSON3(newType)
            }
          }
        };
      }
      prop = visElement.element.properties[key]['@value'];
    }
    return prop['value']["@type"] = typeStringForGraphSON3(newType);
  };

  typeStringForGraphSON3 = function(type) {
    var prefix;
    prefix = 'g';
    if (type === 'Char') {
      prefix = 'gx';
    }
    if (type === 'Byte') {
      prefix = 'gx';
    }
    if (type === 'Geoshape') {
      prefix = 'janusgraph';
    }
    return prefix + ':' + type;
  };

  window.pinVertex = function(id, value) {
    var clientElement, nds, node, state;
    node = clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    state = $('#pinItCheckBoxForId' + node.id).first().is(':checked');
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    return nds.update({
      id: node.id,
      physics: !state
    });
  };

  window.updateElementProps = function(id, elementType) {
    var clientElement, originalProps, props;
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    props = {};
    originalProps = userPropertiesForElement(clientElement.element);
    $('.propForElementID' + id).each(function() { //scanning to get current values from web form
      return props[$(this).attr("name")] = $(this).val();
    });
    return window.updatePropsForElement(elementType, id, props, originalProps);
  };

  window.updateElementPropsGraphSON3 = function(id, elementType) {
    var clientElement, originalProps, props;
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    props = {};
    originalProps = userPropertiesForElementGraphSON3(clientElement.element);
    $('.propForElementID' + id).each(function() { //scanning to get current values from web form
      return props[$(this).attr("name")] = $(this).val();
    });
    return window.updatePropsForElementGraphSON3(elementType, id, props, originalProps);
  };

  javaValueExpressionGraphSON3 = function(element, key, value, type) {
    var expression, num, str;
    if (typeof value === 'string') {
      str = value;
    } else {
      str = JSON.stringify(value);
    }
    if (type === 'String') {
      expression = '"' + str + '"';
      return expression;
    }
    if (type === 'Char') {
      if (str.length > 1) {
        alert('the value for property "' + key + '" should be between a single character (Char).  Truncating "' + str + '" to "' + str.slice(0, 1) + '"');
      }
      if (str.length = 0) {
        alert('the value for property "' + key + '" should be between a single character (Char).  This string is empty.');
      }
      expression = '"' + str.slice(0, 1) + '"';
      return expression;
    }
    if (type === 'Byte') {
      // a byte in Java/Groovy is short between -127 and 127
      num = Number.parseInt(str);
      if (num < -127 || num > 127) {
        alert('the value for property "' + key + '" should be between -127 and 127 (Byte).  This in not a byte: ' + str);
      }
      expression = num.toString() + ' as byte';
      return expression;
    }
    if (type === 'Int32') {
      num = Number.parseInt(str);
      if (isNaN(num)) {
        alert('the value for property "' + key + '" should be an integer (Int32).  This is not a number: ' + str);
      }
      expression = num.toString() + ' as Integer';
      return expression;
    }
    if (type === 'Int64') {
      num = Number.parseInt(str);
      if (isNaN(num)) {
        alert('the value for property "' + key + '" should be an integer (Int64).  This is not a number: ' + str);
      }
      expression = num.toString() + ' as Long';
      return expression;
    }
    if (type === 'Float') {
      num = Number.parseFloat(str);
      if (isNaN(num)) {
        alert('the value for property "' + key + '" should be a float (Float).  This is not a number: ' + str);
      }
      expression = num.toString() + ' as Float';
      return expression;
    }
    if (type === 'Double') {
      num = Number.parseFloat(str);
      if (isNaN(num)) {
        alert('the value for property "' + key + '" should be a double-precision float (Double).  This is not a number: ' + str);
      }
      expression = num.toString() + ' as Double';
      return expression;
    }
    if (type === 'Boolean') {
      str = str.toLowerCase();
      if (str !== 'true' && str !== 'false') {
        alert('the value for property "' + key + '" should be true or false (Boolean).  This is neither: ' + str);
      }
      expression = str;
      return expression;
    }
    if (type === 'Date') {
      num = Number.parseFloat(str);
      if (isNaN(num)) {
        alert('the value for property "' + key + '" should be integer milliseconds since 1-1-1970 (Date).  This is not a number of milliseconds: ' + str);
      }
      expression = 'new Date(' + num.toString() + ')';
      return expression;
    }
    if (type === 'UUID') {
      if (str.length !== 36) {
        alert('the value for property "' + key + '" should be a 36 character string like "13971916-83be-4b52-9d74-f478d45e2dcd" (UUID).  This is not long enough: ' + str);
      }
      expression = 'UUID.fromString("' + str + '")';
      return expression;
    }
    if (type === 'Class') {
      if (str.length === 0) {
        alert('the value for property "' + key + '" should be a string like "org.apache.tinkerpop.gremlin.structure.Vertex" or "Vertex" (Class).  This is string is empty ' + str);
      }
      expression = str;
      return expression;
    }
    if (type === 'Geoshape') {
      if (!((str.slice(0, "Geoshape.circle".length) === "Geoshape.circle") || (str.slice(0, "POINT".length) === "POINT") || (str.slice(0, "POLYGON".length) === "POLYGON"))) {
        alert('the value for property "' + key + '" should be a string like "POINT (...)" or "POLYGON (...)" etc or "Geoshape.circle(...)" (Geoshape).  This is string is neither: ' + str);
      }
      if (str.slice(0, "Geoshape.circle".length) === "Geoshape.circle") {
        expression = str;
      } else {
        expression = 'Geoshape.fromWkt("' + str + '")';
      }
      console.log(expression);
      return expression;
    }
  };

  geoshapeGraphSON3ToJava = function(g3) {
    var centerCoords, j, len, mod, pt, pts, ptstr, ptstrs, radius, str, type, val, wkt;
    if (g3['coordinates']) {
      pts = g3['coordinates'];
      ptstrs = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = pts.length; j < len; j++) {
          pt = pts[j];
          results1.push(pt.toString());
        }
        return results1;
      })();
      if (pts.length === 2) {
        mod = '';
      }
      if (pts.length === 3) {
        mod = 'Z'; //note we are ignoring the solo M possibility
      }
      if (pts.length === 4) {
        mod = 'ZM';
      }
      str = 'POINT (';
      for (j = 0, len = ptstrs.length; j < len; j++) {
        ptstr = ptstrs[j];
        str = str + ptstr + ' ';
      }
      str = str + ')';
      return str;
    }
    if (g3['geometry']) {
      val = g3['geometry']['@value'];
      type = val[1];
      if (type === 'Circle') {
        centerCoords = valueListFromGraphSON3(val[3]);
        radius = valueFromGraphSON3(val[5]);
        str = 'Geoshape.circle(' + centerCoords[0].toString() + ',' + centerCoords[1].toString() + ',' + radius.toString() + ')';
        return str;
      }
      // otherwise we have a WKT version
      wkt = geoshapeGeometryGraphSON3ToWKT(val);
      return wkt;
    }
  };

  geoshapeGeometryGraphSON3ToWKT = function(val) {
    var list, str, type;
    //val = g3['@value']['geometry']['@value'] or g3['@value']['@value'] in the GeoCollection geometries case
    if (val['@type']) {
      val = val['@value'];
    }
    type = val[1];
    if (type === 'Point') {
      str = 'POINT '; //ignoring Z and M and MZ options for now, only 2D points supported here
      list = wktValueListFromGraphSON3(val[3], 'spaces', false);
      str = str + list;
      return str;
    }
    if (type === 'Polygon') {
      str = 'POLYGON ';
      list = wktValueListFromGraphSON3(val[3], 'commas', false);
      str = str + list;
      return str;
    }
    if (type === 'LineString') {
      str = 'LINESTRING ';
      list = wktValueListFromGraphSON3(val[3], 'commas', false);
      str = str + list;
      return str;
    }
    if (type === 'MultiPoint') {
      str = 'MULTIPOINT ';
      list = wktValueListFromGraphSON3(val[3], 'commas', false);
      str = str + list;
      return str;
    }
    if (type === 'MultiLineString') {
      str = 'MULTILINESTRING ';
      list = wktValueListFromGraphSON3(val[3], 'commas', false);
      str = str + list;
      return str;
    }
    if (type === 'MultiPolygon') {
      str = 'MULTIPOLYGON ';
      list = wktValueListFromGraphSON3(val[3], 'commas', false);
      str = str + list;
      return str;
    }
    if (type === 'GeometryCollection') {
      str = 'GEOMETRYCOLLECTION ';
      list = wktValueListFromGraphSON3(val[3], 'commas', true);
      str = str + list;
      return str;
    }
  };

  valueListFromGraphSON3 = function(g3) {
    var inList, item, j, len, outItem, outList;
    if (g3['@type'] !== 'g:List') {
      debugger;
    }
    inList = g3['@value'];
    outList = [];
    for (j = 0, len = inList.length; j < len; j++) {
      item = inList[j];
      if (item['@type'] === 'g:List') { //have a nested list so recurse
        outItem = valueListFromGraphSON3(item);
      } else {
        if (item['@type'] === 'g:Map') { //have a geometry object
          outItem = geoshapeGeometryGraphSON3ToWKT(item);
        } else {
          if (item['@type'] && item['@type'] === 'g:List') {
            outItem = valueListFromGraphSON3(item);
          } else {
            outItem = item['@value'];
          }
        }
      }
      outList.push(outItem);
    }
    return outList;
  };

  wktValueListFromGraphSON3 = function(g3, seps, geocol) {
    var list;
    list = valueListFromGraphSON3(g3);
    return wktValueListFromValueList(list, seps, geocol);
  };

  wktValueListFromValueList = function(list, seps, geocol) {
    var item, itemstr, j, len, origSep, sep, str;
    if (seps === 'spaces') {
      sep = ' ';
    } else {
      sep = ',';
    }
    origSep = sep;
    str = '(';
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      if (item === void 0) {
        debugger;
      }
      if (Array.isArray(item)) {
        itemstr = wktValueListFromValueList(item, seps);
      } else {
        if (item['@type'] && (item['@type'] === 'g:List')) {
          itemstr = wktValueListFromGraphSON3(item, seps);
        } else {
          if (item['@type'] && (item['@type'] === 'g:List')) {
            itemstr = wktValueListFromGraphSON3(item, seps);
          } else {
            itemstr = item.toString();
            sep = ' ';
          }
        }
      }
      if (geocol) {
        str = str + itemstr + ',';
      } else {
        str = str + itemstr + sep;
      }
      sep = origSep;
    }
    str = str.slice(0, -1);
    str = str + ')';
    return str;
  };

  valueFromGraphSON3 = function(g3) {
    //any other type is assumed to be a number and ok to use value directly
    return g3['@value'];
  };

  window.updatePropsForElementGraphSON3 = function(elementType, id, newProps, oldProps) {
    var allKeys, bindings, changedProps, changedTypes, clientElement, j, key, keys2Delete, l, len, len1, len2, m, propType, propTypes, propVal, ref, ref1, request, script, startTime;
    $('.commitButtonForElementID' + id).hide();
    keys2Delete = [];
    ref = _.keys(oldProps);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if (newProps[key] === void 0) {
        keys2Delete.push(key);
      }
    }
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    script = '';
    if (keys2Delete.length > 0) {
      //$(".propTableForElementID"+id).parent().parent().parent().height($(".propTableForElementID"+id).parent().parent().parent().height()-28)
      if (elementType === "vertex") {
        script = script + 'keys2Delete.each { g.V(vID).properties(it).drop()}';
      } else {
        script = script + 'keys2Delete.each { g.E(vID).properties(it).drop()}';
      }
      bindings = {
        keys2Delete: keys2Delete,
        vID: id
      };
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, key2Delete, l, len1, results, results1;
          endTime = Date.now();
          console.log(msg);
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElementGraphSON3(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          }
        };
        //set up request
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: bindings,
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        window.socketToJanus.send(JSON.stringify(request));
      } else {
        Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property remover', script, bindings, function(error, result) {
          var key2Delete, l, len1, results1;
          if (result.success === true) {
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElementGraphSON3(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
    changedProps = {};
    ref1 = _.keys(newProps);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      key = ref1[l];
      if (oldProps[key] === void 0) {
        changedProps[key] = newProps[key];
      } else {
        if (newProps[key].toString() !== oldProps[key].toString()) {
          changedProps[key] = newProps[key];
        }
      }
    }
    changedTypes = propertyTypesChangedGraphSON3(elementType, id);
    propTypes = window.currentPropertyTypesGraphSON3(elementType, id);
    if ((!$.isEmptyObject(changedProps)) || (Object.keys(changedTypes).length > 0)) {
      if (elementType === 'vertex') {
        script = 'v=g.V(' + id + ').next();';
      } else {
        script = 'v=g.E("' + id + '").next();';
      }
      allKeys = _.uniq(_.union(_.keys(changedProps), _.keys(changedTypes)));
      for (m = 0, len2 = allKeys.length; m < len2; m++) {
        key = allKeys[m];
        if (changedProps[key]) {
          propVal = changedProps[key];
        } else {
          propVal = oldProps[key];
        }
        if (changedTypes[key]) {
          propType = changedTypes[key];
        } else {
          propType = propTypes[key];
        }
        script = script + 'v.property("' + key + '",' + javaValueExpressionGraphSON3(clientElement.element, key, propVal, propType) + ');';
      }
      script = script + 'v ';
      console.log(script);
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = results['@value'][0]['@value'];
            clientElement.element.type = elementType;
            turnOffTypeSelectorsForID(id);
            clientElement.title = titleForElementGraphSON3(clientElement.element);
            cacheOriginalPropertyTypeGraphSON3(elementType, id, key, propType);
            //console.log "clientElement=",clientElement
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          }
        };
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          if (result.success === true) {
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = result.results[0];
            clientElement.title = titleForElementGraphSON3(clientElement.element);
            //console.log "clientElement=",clientElement
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
  };

  window.updatePropsForElement = function(elementType, id, newProps, oldProps) {
    var bindings, changedProps, clientElement, j, key, keys2Delete, l, len, len1, len2, m, ref, ref1, ref2, request, script, startTime;
    $('.commitButtonForElementID' + id).hide();
    keys2Delete = [];
    ref = _.keys(oldProps);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if (newProps[key] === void 0) {
        keys2Delete.push(key);
      }
    }
    if (elementType === 'vertex') {
      clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    } else {
      clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
    }
    script = '';
    if (keys2Delete.length > 0) {
      //$(".propTableForElementID"+id).parent().parent().parent().height($(".propTableForElementID"+id).parent().parent().parent().height()-28)
      if (elementType === "vertex") {
        script = script + 'keys2Delete.each { g.V(vID).properties(it).drop()}';
      } else {
        script = script + 'keys2Delete.each { g.E(vID).properties(it).drop()}';
      }
      bindings = {
        keys2Delete: keys2Delete,
        vID: id
      };
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, key2Delete, l, len1, results, results1;
          endTime = Date.now();
          console.log(msg);
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElement(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          }
        };
        //set up request
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: bindings,
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        window.socketToJanus.send(JSON.stringify(request));
      } else {
        Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property remover', script, bindings, function(error, result) {
          var key2Delete, l, len1, results1;
          if (result.success === true) {
            results1 = [];
            for (l = 0, len1 = keys2Delete.length; l < len1; l++) {
              key2Delete = keys2Delete[l];
              clientElement.element.properties = _.omit(clientElement.element.properties, key2Delete);
              clientElement.title = titleForElement(clientElement.element);
              if (elementType === 'vertex') {
                results1.push(window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []));
              } else {
                results1.push(window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []));
              }
            }
            return results1;
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
    changedProps = {};
    ref1 = _.keys(newProps);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      key = ref1[l];
      if (oldProps[key] === void 0) {
        changedProps[key] = newProps[key];
      } else {
        if (newProps[key].toString() !== oldProps[key].toString()) {
          changedProps[key] = newProps[key];
        }
      }
    }
    if (!$.isEmptyObject(changedProps)) {
      if (elementType === 'vertex') {
        script = 'v=g.V(' + id + ').next();';
      } else {
        script = 'v=g.E("' + id + '").next();';
      }
      ref2 = _.keys(changedProps);
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        key = ref2[m];
        script = script + 'v.property("' + key + '","' + changedProps[key] + '");';
      }
      script = script + 'v ';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
            } else {
              results = json.result.data;
            }
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = results[0];
            clientElement.title = titleForElement(clientElement.element);
            //console.log "clientElement=",clientElement
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          }
        };
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          if (result.success === true) {
            if (elementType === 'vertex') {
              clientElement = window.visnetwork.nodesHandler.body.data.nodes._data[id];
            } else {
              clientElement = window.visnetwork.edgesHandler.body.data.edges._data[id];
            }
            clientElement.element = result.results[0];
            clientElement.title = titleForElement(clientElement.element);
            //console.log "clientElement=",clientElement
            delete clientElement.x;
            delete clientElement.y;
            if (elementType === 'vertex') {
              window.visnetwork.nodesHandler.body.data.nodes.update([clientElement], []);
            } else {
              window.visnetwork.edgesHandler.body.data.edges.update([clientElement], []);
            }
            return getLabelSets();
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
  };

  getLabelSets = function() {
    var edge, edgeLabels, edgePropKeys, edges, j, l, len, len1, node, nodeLabels, nodePropKeys, nodes, sorted;
    nodes = _.values(window.visnetwork.nodesHandler.body.data.nodes._data);
    edges = _.values(window.visnetwork.edgesHandler.body.data.edges._data);
    nodeLabels = _.uniq((function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = nodes.length; j < len; j++) {
        node = nodes[j];
        results1.push(node.element.label);
      }
      return results1;
    })());
    edgeLabels = _.uniq((function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = edges.length; j < len; j++) {
        edge = edges[j];
        results1.push(edge.element.label);
      }
      return results1;
    })());
    nodePropKeys = [];
    edgePropKeys = [];
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (node.element.properties) {
        nodePropKeys = _.union(nodePropKeys, _.keys(node.element.properties));
      }
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      if (edge.element.properties) {
        edgePropKeys = _.union(edgePropKeys, _.keys(edge.element.properties));
      }
    }
    sorted = _.sortBy(nodeLabels, function(it) {
      return it;
    });
    Session.set('vertexLabelSet', sorted);
    sorted = _.sortBy(edgeLabels, function(it) {
      return it;
    });
    Session.set('edgeLabelSet', sorted);
    sorted = _.sortBy(_.union(nodePropKeys, edgePropKeys), function(it) {
      return it;
    });
    return Session.set('vertexPropertyNames', sorted);
  };

  window.updateVertexLabelBootBox = function(ctxt) {
    return $('input.bootbox-input.bootbox-input-text.form-control')[0].value = ctxt.value;
  };

  addVertToGraph = function(nodeData, callback) {
    var j, keyForLabel, label, labelSelectorHTML, labels, len, optionHTML;
    //nodeData is the vis.js object for its newly created node on the client
    keyForLabel = Session.get('keyForNodeLabel');
    labels = Session.get('vertexLabelSet');
    labelSelectorHTML = '<select onchange="window.updateVertexLabelBootBox(this)">';
    optionHTML = '<option>Select a vertex label</option>';
    labelSelectorHTML = labelSelectorHTML + optionHTML;
    for (j = 0, len = labels.length; j < len; j++) {
      label = labels[j];
      (function(label) {
        optionHTML = '<option>' + label + '</option>';
        return labelSelectorHTML = labelSelectorHTML + optionHTML;
      })(label);
    }
    labelSelectorHTML = labelSelectorHTML + '</select>';
    label = "";
    return bootbox.prompt("<p>Enter the label for this new vertex or choose one of these " + labelSelectorHTML + "</p><p>Vertex labels are immutable (can't be changed), so choose wisely.</p>", function(result) {
      var request, script, startTime;
      label = result;
      if (label === null || label === "") {
        //alert "Vertices must have labels, adding vertex aborted"
        callback(null);
        return;
      }
      script = 'g.addV("' + label + '")';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, endTime, json, results, v;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
              nodeData = [];
            } else {
              if (window.UsingGraphSON3) {
                results = json.result.data['@value'];
                v = results[0]['@value'];
                v.type = 'vertex';
              } else {
                results = json.result.data;
                v = results[0];
              }
              if ((Session.get('tinkerPopVersion')) === '3') {
                nodeData.id = String(v.id);
              } else {
                nodeData.id = String(v._id);
              }
              nodeData.allowedToMoveX = true;
              nodeData.allowedToMoveY = true;
              if (window.UsingGraphSON3) {
                nodeData.id = v.id['@value'];
                nodeData.title = titleForElementGraphSON3(v);
                nodeData.label = labelForVertexGraphSON3(v, keyForLabel);
              } else {
                nodeData.title = titleForElement(v);
                nodeData.label = labelForVertex(v, keyForLabel);
              }
              nodeData.element = v;
              nodeData.physics = false; // start out pinned
            }
            //console.log nodeData,v
            getLabelSets();
            return callback(nodeData);
          }
        };
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          var v;
          if (result.success === true) {
            if (window.UsingGraphSON3) {
              v = result.results['@value']['@value'][0];
              v.type = 'vertex';
            } else {
              v = result.results[0];
            }
            if ((Session.get('tinkerPopVersion')) === '3') {
              nodeData.id = String(v.id);
            } else {
              nodeData.id = String(v._id);
              if (window.UsingGraphSON3) {
                nodeData.title = titleForElementGraphSON3(v);
                nodeData.label = labelForVertexGraphSON3(v, keyForLabel);
              } else {
                nodeData.title = titleForElement(v);
                nodeData.label = labelForVertex(v, keyForLabel);
              }
            }
            nodeData.allowedToMoveX = true;
            nodeData.allowedToMoveY = true;
            nodeData.element = v;
            nodeData.physics = false; // start out pinned
            //console.log nodeData,v
            getLabelSets();
            return callback(nodeData);
          } else {
            return alert("Graph update failed.  Nothing changed");
          }
        });
      }
    });
  };

  cloneVertToGraph = function(id) {
    var j, key, len, node2Clone, ref, request, script, startTime, v2c, vertex2Clone;
    //id is the tinkerpop id for the vertex to be cloned
    node2Clone = window.visnetwork.body.data.nodes._data[id];
    vertex2Clone = node2Clone.element;
    script = 'g.addV("' + vertex2Clone.label + '")';
    v2c = _.clone(vertex2Clone);
    delete v2c.type;
    delete v2c.label;
    delete v2c.id;
    if (v2c['properties']) {
      ref = Object.keys(v2c.properties);
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        script = script + '.property("' + key + '","' + v2c.properties[key][0].value + '")';
      }
    }
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json, newNode, oldLoc, results, v;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (window.UsingGraphSON3) {
            results = json.result.data['@value'];
            v = results[0]['@value'];
            v.type = 'vertex';
            newNode = {
              id: String(v.id['@value']),
              label: labelForVertexGraphSON3(v, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElementGraphSON3(v),
              element: v
            };
          } else {
            results = json.result.data;
            v = results[0];
            newNode = {
              id: String(v.id),
              label: labelForVertex(v, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(v),
              element: v
            };
          }
          window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
          oldLoc = (window.visnetwork.getPositions([node2Clone.id]))[node2Clone.id];
          window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
          return window.visnetwork.setSelection({
            nodes: [newNode.id],
            edges: []
          }, {
            unselectedAll: false,
            highlightEdges: false
          });
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {},
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Vertex cloner', script, function(error, result) {
        var newNode, oldLoc, results, v;
        if (result.success === true) {
          if (window.UsingGraphSON3) {
            results = json.result.data['@value'];
            v = results[0]['@value'];
            v.type = 'vertex';
            newNode = {
              id: String(v.id['@value']),
              label: labelForVertexGraphSON3(v, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElementGraphSON3(v),
              element: v
            };
          } else {
            v = result.results[0];
            newNode = {
              id: String(v.id),
              label: labelForVertex(v, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(v),
              element: v
            };
          }
          window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
          oldLoc = (window.visnetwork.getPositions([node2Clone.id]))[node2Clone.id];
          window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
          return window.visnetwork.setSelection({
            nodes: [newNode.id],
            edges: []
          }, {
            unselectedAll: false,
            highlightEdges: false
          });
        } else {
          return alert("Graph update failed.  Nothing changed: " + script);
        }
      });
    }
  };

  arrayFromGraphSON3List = function(g3) {
    if (!g3['@type'] === 'g:List') {
      debugger;
    }
    return g3['@value'];
  };

  objectFromGraphSON3Map = function(g3) {
    var j, key, list, obj, ref, x;
    if (!g3['@type'] === 'g:Map') {
      debugger;
    }
    list = g3['@value'];
    obj = {};
    for (x = j = 0, ref = list.length - 1; j < ref; x = j += 2) {
      if (list[x]['@type'] === "janusgraph:RelationIdentifier") {
        key = list[x]['@value']['relationId'];
      } else {
        key = list[x]['@value'];
      }
      obj[key] = list[x + 1]['@value'];
    }
    return obj;
  };

  //-------------for use from Context UI-----------------------
  invertSelections = function() {
    var allEdges, allNodes, edge, edges2Select, node, nodes2Select, selectedEdges, selectedNodes, selections;
    //swap unselected with selected
    allNodes = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    allEdges = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.edges.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    selections = window.visnetwork.getSelection();
    selectedNodes = selections.nodes;
    selectedEdges = selections.edges;
    nodes2Select = _.difference(allNodes, selectedNodes);
    edges2Select = _.difference(allEdges, selectedEdges);
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    });
  };

  selectAll = function() {
    var edge, edges2Select, node, nodes2Select;
    //select all local nodes and edges
    nodes2Select = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    edges2Select = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.edges.get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    }, {
      unselectedAll: true,
      highlightEdges: false
    });
  };

  selectNone = function() {
    //deselect all local element
    return window.visnetwork.unselectAll();
  };

  layoutSelectionsInCircle = function() {
    var eds, elementIDs, j, len, nds, nodeID, ref, results1;
    elementIDs = window.visnetwork.getSelection();
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    eds = window.visnetwork.edgesHandler.body.data.edges.getDataSet();
    ref = elementIDs.nodes;
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      results1.push(nds.update({
        id: nodeID,
        physics: false
      }));
    }
    return results1;
  };

  //for edgeID in elementIDs.edges
  //  eds.update({id:edgeID, physics: false})
  pinSelections = function() {
    var eds, elementIDs, j, len, nds, nodeID, ref, results1;
    elementIDs = window.visnetwork.getSelection();
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    eds = window.visnetwork.edgesHandler.body.data.edges.getDataSet();
    ref = elementIDs.nodes;
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      results1.push(nds.update({
        id: nodeID,
        physics: false
      }));
    }
    return results1;
  };

  //for edgeID in elementIDs.edges
  //  eds.update({id:edgeID, physics: false})
  unpinSelections = function() {
    var eds, elementIDs, j, len, nds, nodeID, ref, results1;
    elementIDs = window.visnetwork.getSelection();
    nds = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
    eds = window.visnetwork.edgesHandler.body.data.edges.getDataSet();
    ref = elementIDs.nodes;
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      results1.push(nds.update({
        id: nodeID,
        physics: true
      }));
    }
    return results1;
  };

  //for edgeID in elementIDs.edges
  //  eds.update({id:edgeID, physics: true})
  inspectSelections = function() {
    var edgeID, element, elementIDs, elementType, j, l, len, len1, nodeID, ref, ref1, results1;
    elementIDs = window.visnetwork.getSelection();
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      elementType = 'vertex';
      element = window.visnetwork.nodesHandler.body.data.nodes.get(nodeID);
      window.popupPropertyEditor(element, elementType);
    }
    ref1 = elementIDs.edges;
    results1 = [];
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      edgeID = ref1[l];
      elementType = 'edge';
      element = window.visnetwork.edgesHandler.body.data.edges.get(edgeID);
      results1.push(window.popupPropertyEditor(element, elementType));
    }
    return results1;
  };

  shareGremlinCodeForIngestion = function() {
    var script, title, wnd;
    script = scriptForGeneralIngestionFindOrCreate();
    wnd = window.open("", "", "_blank");
    title = "<title>Gremlin code to use with JSON bindings to programmatically add elements</title>";
    return wnd.document.write(title + "<pre><code>" + script + "</code></pre>");
  };

  inputGremlinCodeForIngestion = function() {
    var bindings;
    bindings = JSON.parse(prompt('Paste bindings JSON here'));
    console.log(bindings);
    if (window.UsingGraphSON3) {
      return addElementsFromBindingsJSONGraphSON3(bindings);
    } else {
      return addElementsFromBindingsJSON(bindings);
    }
  };

  generateJSONBindingsForSelections = function() {
    /*
    link = document.createElement('a')
    link.download = 'bindings-for-tinkertools-selections.json'
    blob = new Blob([JSON.stringify(bindings, null, 2)], {type: 'text/plain'})
    link.href = window.URL.createObjectURL(blob)
    link.click()
    */
    var bindings, edge, edgeID, edgesJSON, elementIDs, j, l, len, len1, node, nodeID, ref, ref1, styles, title, vertsJSON, wnd;
    elementIDs = window.visnetwork.getSelection();
    vertsJSON = [];
    styles = {};
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      node = window.visnetwork.nodesHandler.body.data.nodes.get(nodeID);
      vertsJSON.push(node.element);
      styles[nodeID] = _.omit(node, ['element', 'id', 'x', 'y', 'label', 'physics', 'allowedToMoveX', 'allowedToMoveY', 'title']);
    }
    edgesJSON = [];
    ref1 = elementIDs.edges;
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      edgeID = ref1[l];
      edge = window.visnetwork.edgesHandler.body.data.edges.get(edgeID);
      edgesJSON.push(edge.element);
      styles[edgeID] = _.omit(edge, ['element', 'id', 'from', 'to', 'label', 'title']);
    }
    bindings = {
      "verts2FindOrCreate": [],
      "vertsJSON": vertsJSON,
      "edgesJSON": edgesJSON,
      "transactionContext": "ingesting a subgraph",
      "locations": window.visnetwork.getPositions(elementIDs.nodes),
      "styles": styles
    };
    wnd = window.open("", "", "_blank");
    title = "<title>JSON bindings for selected graph elements</title>";
    return wnd.document.write(title + "<pre><code>" + JSON.stringify(bindings, null, 2) + "</code></pre>");
  };

  spawnToQuikVis = function() {
    var allEdges, allNodes, positions;
    allNodes = window.visnetwork.getSelectedNodes();
    allEdges = window.visnetwork.getSelectedEdges();
    positions = window.visnetwork.getPositions(allNodes);
    return spawnTheseToQuikVis("selections", allNodes, allEdges, positions);
  };

  spawnTheseToQuikVis = function(subtitle, allNodes, allEdges, positions) {
    var script, specs, tinkertoolsServerURL, title, url, wnd;
    script = "vertIDs = " + JSON.stringify(allNodes) + "\n";
    script = script + "edgeIDs = " + JSON.stringify(allEdges) + "\n";
    script = script + "if (vertIDs != []) {vs = g.V(vertIDs).toList()}else{vs=[]}" + "\n";
    script = script + "if (edgeIDs != []) {es = g.E(edgeIDs).toList()}else{es=[]}" + "\n";
    script = script + "[vs,es]" + "\n";
    tinkertoolsServerURL = (Meteor.absoluteUrl()).slice(0, -1);
    if (tinkertoolsServerURL.slice(-5) === ':3000') {

    } else {
      tinkertoolsServerURL = tinkertoolsServerURL + ':3000';
    }
    url = tinkertoolsServerURL + "/quikvis?serverURL=" + Session.get('serverURL');
    url = url + '&width="auto"';
    url = url + '&height="1000px"';
    url = url + "&graphName=the default graph";
    url = url + "&scripts=";
    specs = JSON.stringify([
      {
        title: 'Show elements',
        script: script
      }
    ]);
    url = url + encodeURIComponent(specs);
    url = url + "&positions=" + JSON.stringify(positions);
    wnd = window.open("", "", "_blank");
    title = "<title>Spawned " + subtitle + " from Server: " + (Session.get('serverURL')) + "</title>";
    return wnd.document.write(title + "<div></div><h4>From Server: " + (Session.get('serverURL')) + "  Script used</h4><textarea rows='1' cols='150'>" + script + "</textarea></div><iframe width='100%' height='100%' src='" + url + "'>");
  };

  spawnAllToQuikVis = function() {
    var allEdges, allNodes, edge, node, positions;
    allNodes = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.nodesHandler.body.data.nodes.getDataSet().get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        results1.push(node.id);
      }
      return results1;
    })();
    allEdges = (function() {
      var j, len, ref, results1;
      ref = window.visnetwork.edgesHandler.body.data.edges.getDataSet().get();
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        results1.push(edge.id);
      }
      return results1;
    })();
    positions = window.visnetwork.getPositions(allNodes);
    return spawnTheseToQuikVis("graph", allNodes, allEdges, positions);
  };

  inspectNone = function() {
    return $(".ui-dialog").detach();
  };

  hideSelections1 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden1 = window.hidden1 ? window.hidden1 : {
      nodes: [],
      edges: [],
      positions: {}
    };
//pin nodes
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
//unpin edges
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden1.nodes = _.union(window.hidden1.nodes, nodes2Hide);
    window.hidden1.edges = _.union(window.hidden1.edges, edges2Hide);
    window.hidden1.positions = _.extend(window.hidden1.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections1").text("" + window.hidden1.nodes.length + "v," + window.hidden1.edges.length + "e");
  };

  unhideSelections1 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden1 = window.hidden1 ? window.hidden1 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden1.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden1.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden1.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden1.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden1.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden1.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden1 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections1").text("Hide1");
  };

  spawnHidden1 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden1.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden1.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 1", hiddenNodes, hiddenEdges, window.hidden1.positions);
  };

  hideSelections2 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden2 = window.hidden2 ? window.hidden2 : {
      nodes: [],
      edges: [],
      positions: {}
    };
//pin nodes
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
//unpin edges
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden2.nodes = _.union(window.hidden2.nodes, nodes2Hide);
    window.hidden2.edges = _.union(window.hidden2.edges, edges2Hide);
    window.hidden2.positions = _.extend(window.hidden2.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections2").text("" + window.hidden2.nodes.length + "v," + window.hidden2.edges.length + "e");
  };

  unhideSelections2 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden2 = window.hidden2 ? window.hidden2 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden2.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden2.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden2.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden2.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden2.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden2.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden2 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections2").text("Hide2");
  };

  window.hidden2 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden2 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden2.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden2.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 2", hiddenNodes, hiddenEdges, window.hidden2.positions);
  };

  hideSelections3 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden3 = window.hidden3 ? window.hidden3 : {
      nodes: [],
      edges: [],
      positions: {}
    };
//pin nodes
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
//unpin edges
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden3.nodes = _.union(window.hidden3.nodes, nodes2Hide);
    window.hidden3.edges = _.union(window.hidden3.edges, edges2Hide);
    window.hidden3.positions = _.extend(window.hidden3.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections3").text("" + window.hidden3.nodes.length + "v," + window.hidden3.edges.length + "e");
  };

  unhideSelections3 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden3 = window.hidden3 ? window.hidden3 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden3.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden3.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden3.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden3.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden3.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden3.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden3 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections3").text("Hide3");
  };

  window.hidden3 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden3 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden3.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden3.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 3", hiddenNodes, hiddenEdges, window.hidden3.positions);
  };

  hideSelections4 = function() {
    var edge, edges2Hide, elementIDs, j, l, len, len1, node, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.hidden4 = window.hidden4 ? window.hidden4 : {
      nodes: [],
      edges: [],
      positions: {}
    };
//pin nodes
    for (j = 0, len = nodes2Hide.length; j < len; j++) {
      node = nodes2Hide[j];
      node.physics = false;
    }
//unpin edges
    for (l = 0, len1 = edges2Hide.length; l < len1; l++) {
      edge = edges2Hide[l];
      edge.physics = true;
    }
    window.hidden4.nodes = _.union(window.hidden4.nodes, nodes2Hide);
    window.hidden4.edges = _.union(window.hidden4.edges, edges2Hide);
    window.hidden4.positions = _.extend(window.hidden4.positions, window.visnetwork.getPositions(elementIDs.nodes));
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
    window.visnetwork.setSelection({
      nodes: [],
      edges: []
    });
    return $(".context-hideSelections4").text("" + window.hidden4.nodes.length + "v," + window.hidden4.edges.length + "e");
  };

  unhideSelections4 = function() {
    var each, j, len, node, oldLoc, ref;
    window.hidden4 = window.hidden4 ? window.hidden4 : {
      nodes: [],
      edges: [],
      positions: {}
    };
    window.visnetwork.body.data.nodes.getDataSet().add(window.hidden4.nodes);
    window.visnetwork.body.data.edges.getDataSet().add(window.hidden4.edges);
    window.visnetwork.setSelection({
      nodes: (function() {
        var j, len, ref, results1;
        ref = window.hidden4.nodes;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })(),
      edges: (function() {
        var j, len, ref, results1;
        ref = window.hidden4.edges;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          each = ref[j];
          results1.push(each.id);
        }
        return results1;
      })()
    });
    ref = window.hidden4.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      oldLoc = window.hidden4.positions[node.id];
      window.visnetwork.moveNode(node.id, oldLoc.x, oldLoc.y);
    }
    window.hidden4 = {
      nodes: [],
      edges: [],
      positions: {}
    };
    return $(".context-hideSelections4").text("Hide4");
  };

  window.hidden4 = {
    nodes: [],
    edges: [],
    positions: {}
  };

  spawnHidden4 = function() {
    var each, hiddenEdges, hiddenNodes;
    hiddenNodes = (function() {
      var j, len, ref, results1;
      ref = window.hidden4.nodes;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    hiddenEdges = (function() {
      var j, len, ref, results1;
      ref = window.hidden4.edges;
      results1 = [];
      for (j = 0, len = ref.length; j < len; j++) {
        each = ref[j];
        results1.push(each.id);
      }
      return results1;
    })();
    return spawnTheseToQuikVis("contents of hidden buffer 4", hiddenNodes, hiddenEdges, window.hidden4.positions);
  };

  allHiddenNodeIDs = function() {
    var each, j, len, ref, results1;
    ref = window.hidden1.nodes.concat(window.hidden2.nodes, window.hidden3.nodes, window.hidden4.nodes);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      each = ref[j];
      results1.push(each.id);
    }
    return results1;
  };

  allHiddenEdgeIDs = function() {
    var each, j, len, ref, results1;
    ref = window.hidden1.edges.concat(window.hidden2.edges, window.hidden3.edges, window.hidden4.edges);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      each = ref[j];
      results1.push(each.id);
    }
    return results1;
  };

  dropSelections = function() {
    var edges2Hide, elementIDs, nodes2Hide;
    elementIDs = window.visnetwork.getSelection();
    nodes2Hide = window.visnetwork.body.data.nodes.getDataSet().get(elementIDs.nodes);
    edges2Hide = window.visnetwork.body.data.edges.getDataSet().get(elementIDs.edges);
    window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
    return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
  };

  growSelections = function() {
    var bindings, elementIDs, nl, request, script, startTime;
    //grow means add neighboring vertices and their edges from the database into the local render
    elementIDs = window.visnetwork.getSelection();
    if (elementIDs.nodes.length > 0) {
      bindings = {
        vIDs: elementIDs.nodes
      };
      nl = "\n";
      script = "//answer all neighbors to these node IDs, vIDs is a binding" + nl + "inVs = vIDs.collect { g.V(it).in().toList() }" + nl + "inVs = inVs.flatten().unique()" + nl + "outVs = vIDs.collect { g.V(it).out().toList() }" + nl + "outVs = outVs.flatten().unique()" + nl + "inEs = vIDs.collect { g.V(it).inE().toList() }" + nl + "inEs = inEs.flatten().unique()" + nl + "outEs = vIDs.collect { g.V(it).outE().toList() }" + nl + "outEs = outEs.flatten().unique()" + nl + "[inVs,outVs,inEs,outEs]";
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var ahe, ahn, allE, allV, data, edges2Select, eds, endTime, inEs, inVs, json, nds, nodes2Select, outEs, outVs, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              return results = [];
            } else {
              results = json.result.data;
              nds = window.visnetwork.body.data.nodes.getDataSet();
              eds = window.visnetwork.body.data.edges.getDataSet();
              inVs = _.filter(results[0], function(e) {
                return nds.get(e.id) === null;
              });
              outVs = _.filter(results[1], function(e) {
                return nds.get(e.id) === null;
              });
              inEs = _.filter(results[2], function(e) {
                return eds.get(e.id) === null;
              });
              outEs = _.filter(results[3], function(e) {
                return eds.get(e.id) === null;
              });
              allV = _.uniq(_.union(inVs, outVs));
              ahn = allHiddenNodeIDs();
              allV = _.reject(allV, function(node) {
                return _.contains(ahn, node.id + "");
              });
              allE = _.uniq(_.union(inEs, outEs));
              ahe = allHiddenEdgeIDs();
              allE = _.reject(allE, function(edge) {
                return _.contains(ahe, edge.id);
              });
              nodes2Select = _.initial(elementIDs.nodes, 0);
              edges2Select = _.initial(elementIDs.edges, 0);
              if (allV.length > 100) {
                //too many to auto insert without user permissions and selection
                return selectNeighborsToAdd(nodes2Select, edges2Select, allV, allE);
              } else {
                return addInTheNeighbors(nodes2Select, edges2Select, allV, allE);
              }
            }
          }
        };
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: bindings,
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Get neighbors', script, bindings, function(error, result) {
          var ahe, ahn, allE, allV, edges2Select, eds, inEs, inVs, nds, nodes2Select, outEs, outVs, results;
          if (result.success === true) {
            results = result.results;
            console.log(results);
            nds = window.visnetwork.body.data.nodes.getDataSet();
            eds = window.visnetwork.body.data.edges.getDataSet();
            inVs = _.filter(results[0], function(e) {
              return nds.get(e.id) === null;
            });
            outVs = _.filter(results[1], function(e) {
              return nds.get(e.id) === null;
            });
            inEs = _.filter(results[2], function(e) {
              return eds.get(e.id) === null;
            });
            outEs = _.filter(results[3], function(e) {
              return eds.get(e.id) === null;
            });
            allV = _.uniq(_.union(inVs, outVs));
            ahn = allHiddenNodeIDs();
            allV = _.reject(allV, function(node) {
              return _.contains(ahn, node.id + "");
            });
            allE = _.uniq(_.union(inEs, outEs));
            ahe = allHiddenEdgeIDs();
            allE = _.reject(allE, function(edge) {
              return _.contains(ahe, edge.id);
            });
            nodes2Select = _.initial(elementIDs.nodes, 0);
            edges2Select = _.initial(elementIDs.edges, 0);
            if (allV.length + allE.length > 20) {
              //too many to auto insert without user permissions and selection
              return selectNeighborsToAdd(nodes2Select, edges2Select, allV, allE);
            } else {
              return addInTheNeighbors(nodes2Select, edges2Select, allV, allE);
            }
          } else {
            return alert("Graph update failed.  Nothing changed.  Maybe try again?");
          }
        });
      }
    }
  };

  expandSelections = function() {
    var edgeID, edges2Select, elementIDs, j, l, len, len1, len2, len3, m, n, newEdge, newEdges, newNode, newNodes, nodeID, nodes2Select, ref, ref1;
    //expanding means select nodes add edges to selection and selected edges add nodes
    elementIDs = window.visnetwork.getSelection();
    nodes2Select = _.initial(elementIDs.nodes, 0);
    edges2Select = _.initial(elementIDs.edges, 0);
    ref = elementIDs.nodes;
    for (j = 0, len = ref.length; j < len; j++) {
      nodeID = ref[j];
      newEdges = window.visnetwork.getConnectedEdges(nodeID);
      for (l = 0, len1 = newEdges.length; l < len1; l++) {
        newEdge = newEdges[l];
        edges2Select.push(newEdge);
      }
    }
    ref1 = elementIDs.edges;
    for (m = 0, len2 = ref1.length; m < len2; m++) {
      edgeID = ref1[m];
      newNodes = window.visnetwork.getConnectedNodes(edgeID);
      for (n = 0, len3 = newNodes.length; n < len3; n++) {
        newNode = newNodes[n];
        nodes2Select.push(newNode);
      }
    }
    return window.visnetwork.setSelection({
      nodes: _.uniq(nodes2Select),
      edges: _.uniq(edges2Select)
    });
  };

  expandSelections5 = function() {
    //expanding means select nodes add edges to selection and selected edges add nodes
    //take it out to 5 levels of neighbors
    expandSelections();
    expandSelections();
    expandSelections();
    expandSelections();
    return expandSelections();
  };

  deleteSelections = function() {
    var bindings, elementIDs, request, script, startTime;
    elementIDs = window.visnetwork.getSelection();
    bindings = {
      "vertIDs": elementIDs.nodes,
      "edgeIDs": elementIDs.edges
    };
    script = "//given arrays of vert ids and edge ids, remove their elements in the graph" + "\n";
    if (elementIDs.nodes.length > 0) {
      script = script + "g.V(vertIDs).drop().iterate()" + "\n";
    }
    if (elementIDs.edges.length > 0) {
      script = script + "g.E(edgeIDs).drop().iterate()" + "\n";
    }
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
          return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('usingWebServices'), 'Deleting a collection of verts and edges by id', script, bindings, function(error, result) {
        if (result.success === true) {
          window.visnetwork.body.data.edges.getDataSet().remove(elementIDs.edges);
          return window.visnetwork.body.data.nodes.getDataSet().remove(elementIDs.nodes);
        } else {
          return alert("Selection deletion failed.  Nothing changed; " + script);
        }
      });
    }
  };

  cloneSelections = function() {
    var elementIDs;
    elementIDs = window.visnetwork.getSelection();
    return cloneElements(elementIDs);
  };

  //-----------------for use from other functions-----------------
  addElementsFromBindingsJSON = function(bindings) {
    var request, script, startTime;
    //Ignoring the case where GraphSON3 bindings are ingested into GraphSON1 graph.....this will BREAK
    script = 'if (bindings[\'vertsJSON\'] == null) {vertsJSON = []} else {vertsJSON = bindings[\'vertsJSON\']}\nif (bindings[\'edgesJSON\'] == null) {edgesJSON = []} else {edgesJSON = bindings[\'edgesJSON\']}\nif (bindings[\'verts2FindOrCreate\'] == null) {verts2FindOrCreate = []} else {verts2FindOrCreate = bindings[\'verts2FindOrCreate\']}\nif (bindings[\'transactionContext\'] == null) {transactionContext = \'unlabeled transaction context\'} else {transactionContext = bindings[\'transactionContext\']}\n\nvMap = [:]\nvMapFull = [:]\neMapFull = [:]\nverts2FindOrCreate.collect { json ->\n    trav = g.V().hasLabel(json.label)\n    json.properties.each { key, val ->\n        trav = trav.has(key, val[0].value)\n        }\n    results = trav.toList()\n   if (results.size == 0) {oldV = null} else {oldV = results[0]}\n    if (oldV == null){\n        //create it\n        newV = g.addV(json.label).next()\n        json.properties.each { key, val ->\n            g.V(newV.id()).property(key, val[0].value).next()\n            }\n    } else {\n        //reference it\n        newV = oldV\n    }\n    vMap[json.id] = newV.id()\n\n}\n\n\nvertsJSON.collect { json ->\n    newV = g.addV(json.label).next()\n    vMap[json.id] = newV.id()\n    vMapFull[json.id] = newV\n    json.properties.each { key, val ->\n        g.V(newV.id()).property(key, val[0].value).next()\n}}\nedgesJSON.collect { json ->\n    fromID = vMap[json.outV] ? vMap[json.outV] : json.outV\n    toID = vMap[json.inV] ? vMap[json.inV] : json.inV\n    newEdge=g.V(fromID).addE(json.label).to(g.V(toID)).next()\n    eMapFull[json.id] = newEdge\n    json.properties.collect { key, val ->\n        g.E(newEdge.id()).property(key, val.value).next()\n}}\n//answer the maps of old element ids to new elements\n[vMapFull, eMapFull]';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, eMap, edgeIDsToSelect, endTime, json, loc, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldVID, results, styleForEdge, styleForNode, vMap;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            return results = [];
          } else {
            results = json.result.data;
            vMap = results[0];
            eMap = results[1];
            nodeIDsToSelect = [];
            edgeIDsToSelect = [];
            for (oldVID in vMap) {
              newV = vMap[oldVID];
              newNode = {
                physics: false,
                id: String(newV.id),
                label: labelForVertex(newV, Session.get('keyForNodeLabel')),
                allowedToMoveX: true,
                allowedToMoveY: true,
                title: titleForElement(newV),
                element: newV
              };
              window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
              if (bindings['locations'] && bindings.locations[oldVID]) {
                loc = bindings.locations[oldVID.toString()];
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              } else {
                window.visnetwork.moveNode(newNode.id, 0, 0);
              }
              if (bindings['styles'] && bindings.styles[oldVID.toString()]) {
                styleForNode = bindings.styles[oldVID.toString()];
                newNode = _.extend(newNode, styleForNode);
                window.visnetwork.nodesHandler.body.data.nodes.getDataSet().update(newNode);
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              }
              nodeIDsToSelect.push(newNode.id);
            }
            for (oldEID in eMap) {
              newE = eMap[oldEID];
              newEdge = {
                id: String(newE.id),
                label: newE.label,
                from: newE.outV,
                to: newE.inV,
                title: titleForElement(newE),
                element: newE
              };
              if (bindings['styles'] && bindings.styles[oldEID.toString()]) {
                styleForEdge = bindings.styles[oldEID.toString()];
                newEdge = _.extend(newEdge, styleForEdge);
              }
              window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
              edgeIDsToSelect.push(newEdge.id);
            }
            return window.visnetwork.setSelection({
              nodes: nodeIDsToSelect,
              edges: edgeIDsToSelect
            }, {
              unselectedAll: true,
              highlightEdges: false
            });
          }
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {
            bindings: bindings
          },
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Subgraph ingestor from bindings JSON', script, {
        bindings: bindings
      }, function(error, result) {
        var eMap, edgeIDsToSelect, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, vMap;
        if (result.success === true) {
          vMap = result.results[0];
          eMap = result.results[1];
          nodeIDsToSelect = [];
          edgeIDsToSelect = [];
          for (oldVID in vMap) {
            newV = vMap[oldVID];
            newNode = {
              id: String(newV.id),
              label: labelForVertex(newV, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(newV),
              element: newV
            };
            window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
            oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
            window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
            nodeIDsToSelect.push(newNode.id);
          }
          for (oldEID in eMap) {
            newE = eMap[oldEID];
            newEdge = {
              id: String(newE.id),
              label: newE.label,
              from: newE.outV,
              to: newE.inV,
              title: titleForElement(newE),
              element: newE
            };
            window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
            edgeIDsToSelect.push(newEdge.id);
          }
          return window.visnetwork.setSelection({
            nodes: nodeIDsToSelect,
            edges: edgeIDsToSelect
          }, {
            unselectedAll: true,
            highlightEdges: false
          });
        } else {
          return alert("Selection cloning failed.  Nothing changed; " + script);
        }
      });
    }
  };

  addElementsFromBindingsJSONGraphSON3 = function(bindings) {
    var request, script, startTime;
    //Need to handle the case where GraphSON1 bindings are ingested into GraphSON3 graph
    console.log(bindings);
    script = 'println \'***************************************************************************************\'\nprintln bindings\nprintln \'***************************************************************************************\'\nif (bindings[\'vertsJSON\'] == null) {vertsJSON = []} else {vertsJSON = bindings[\'vertsJSON\']}\nif (bindings[\'edgesJSON\'] == null) {edgesJSON = []} else {edgesJSON = bindings[\'edgesJSON\']}\nvMap = [:]\nvMapFull = [:]\neMapFull = [:]\n\nvertsJSON.collect { json ->\n    newV = g.addV(json.label).next()\n    println \'-------------\'\n    println json\n    println "ingestId="+json.id.toString()\n    println "newId="+newV.id().toString()\n    println \'-------------\'\n    vMap[json.id] = newV.id()\n    vMapFull[json.id] = newV\n  if(json[\'properties\'] != null){\n    json.properties.each { key, val ->\nprintln "--------v---------->   "+val[0].toString()\nprintln "--------v---------->   "+val[0].value().toString()\n       g.V(newV.id()).property(key, val[0].value()).next()\n}\n}}\nedgesJSON.collect { json ->\n   println \'-------------\'\n    println json\n    println "ingestId="+json.id.toString()\n    fromID = vMap[json.outV] ? vMap[json.outV] : json.outV\n    toID = vMap[json.inV] ? vMap[json.inV] : json.inV\n    newEdge=g.V(fromID).addE(json.label).to(g.V(toID)).next()\n    eMapFull[json.id] = newEdge\n     println "newEdgeId="+newEdge.id().toString()\n    println \'-------------\'\n\n  if (json[\'properties\'] != null){\n    json.properties.collect { key, val ->\nprintln "--------e---------->   "+val.toString()\n        g.E(newEdge.id()).property(key, val.value()).next()\n}\n}}\n//answer the maps of old element ids to new elements\n[vMapFull, eMapFull]';
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, eMap, edgeIDsToSelect, endTime, json, loc, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldVID, results, styleForEdge, styleForNode, vMap;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            return results = [];
          } else {
            results = json.result.data;
            vMap = objectFromGraphSON3Map(results['@value'][0]);
            eMap = objectFromGraphSON3Map(results['@value'][1]);
            nodeIDsToSelect = [];
            edgeIDsToSelect = [];
            for (oldVID in vMap) {
              newV = vMap[oldVID];
              newV.type = 'vertex';
              newNode = {
                physics: false,
                id: String(newV.id['@value']),
                label: labelForVertexGraphSON3(newV, Session.get('keyForNodeLabel')),
                allowedToMoveX: true,
                allowedToMoveY: true,
                title: titleForElementGraphSON3(newV),
                element: newV
              };
              window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
              if (bindings['locations'] && bindings.locations[oldVID]) {
                loc = bindings.locations[oldVID.toString()];
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              } else {
                window.visnetwork.moveNode(newNode.id, 0, 0);
              }
              if (bindings['styles'] && bindings.styles[oldVID.toString()]) {
                styleForNode = bindings.styles[oldVID.toString()];
                newNode = _.extend(newNode, styleForNode);
                window.visnetwork.nodesHandler.body.data.nodes.getDataSet().update(newNode);
                window.visnetwork.moveNode(newNode.id, loc.x, loc.y);
              }
              nodeIDsToSelect.push(newNode.id);
            }
            for (oldEID in eMap) {
              newE = eMap[oldEID];
              newE.type = 'edge';
              newEdge = {
                id: String(newE.id['@value']['relationId']),
                label: newE.label,
                from: newE.outV['@value'],
                to: newE.inV['@value'],
                title: titleForElementGraphSON3(newE),
                element: newE
              };
              if (bindings['styles'] && bindings.styles[oldEID.toString()]) {
                styleForEdge = bindings.styles[oldEID.toString()];
                newEdge = _.extend(newEdge, styleForEdge);
              }
              window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
              edgeIDsToSelect.push(newEdge.id);
            }
            return window.visnetwork.setSelection({
              nodes: nodeIDsToSelect,
              edges: edgeIDsToSelect
            }, {
              unselectedAll: true,
              highlightEdges: false
            });
          }
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {
            bindings: bindings
          },
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Subgraph ingestor from bindings JSON', script, {
        bindings: bindings
      }, function(error, result) {
        var eMap, edgeIDsToSelect, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, vMap;
        if (result.success === true) {
          vMap = result.results[0];
          eMap = result.results[1];
          nodeIDsToSelect = [];
          edgeIDsToSelect = [];
          for (oldVID in vMap) {
            newV = vMap[oldVID];
            newNode = {
              id: String(newV.id),
              label: labelForVertex(newV, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(newV),
              element: newV
            };
            window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
            oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
            window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
            nodeIDsToSelect.push(newNode.id);
          }
          for (oldEID in eMap) {
            newE = eMap[oldEID];
            newEdge = {
              id: String(newE.id),
              label: newE.label,
              from: newE.outV,
              to: newE.inV,
              title: titleForElement(newE),
              element: newE
            };
            window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
            edgeIDsToSelect.push(newEdge.id);
          }
          return window.visnetwork.setSelection({
            nodes: nodeIDsToSelect,
            edges: edgeIDsToSelect
          }, {
            unselectedAll: true,
            highlightEdges: false
          });
        } else {
          return alert("Selection cloning failed.  Nothing changed; " + script);
        }
      });
    }
  };

  cloneElements = function(elementIDs) {
    var bindings, request, script, startTime;
    bindings = {
      "vertIDs": elementIDs.nodes,
      "edgeIDs": elementIDs.edges
    };
    script = "//given arrays of vert ids and edge ids, clone the subgraph defined into the graph" + "\n";
    // use bindings instead of codegen to reuse last compiled version of script
    //  script = script + "vertIDs = "+JSON.stringify(elementIDs.nodes)+"\n"
    //  script = script + "edgeIDs = "+JSON.stringify(elementIDs.edges)+"\n"
    script = script + "//clone vertices first" + "\n";
    script = script + "vMap = [:]" + "\n";
    script = script + "vMapFull = [:]" + "\n";
    script = script + "vertIDs.each { id ->" + "\n";
    script = script + "   oldVert = g.V(id).next()" + "\n";
    script = script + "   newVert = g.addV(oldVert.label()).next()" + "\n";
    script = script + "   vMap[oldVert.id()] = newVert.id()" + "\n";
    script = script + "   vMapFull[oldVert.id()] = newVert" + "\n";
    script = script + "   oldVert.properties().toList().collect {prop ->" + "\n";
    script = script + "       g.V(newVert.id()).property(prop.label(), prop.value()).next()" + "\n";
    script = script + "}}" + "\n";
    script = script + "//clone edges" + "\n";
    script = script + "eMapFull = [:]" + "\n";
    script = script + "edgeIDs.each { id ->" + "\n";
    script = script + "   oldEdge = g.E(id).next()" + "\n";
    script = script + "   fromID = vMap[oldEdge.outVertex().id()] ? vMap[oldEdge.outVertex().id()] : oldEdge.outVertex().id()" + "\n";
    script = script + "   toID = vMap[oldEdge.inVertex().id()] ? vMap[oldEdge.inVertex().id()] : oldEdge.inVertex().id()" + "\n";
    script = script + "   newEdge=g.V(fromID).addE(oldEdge.label()).to(g.V(toID)).next()" + "\n";
    script = script + "   eMapFull[oldEdge.id()] = newEdge" + "\n";
    script = script + "   oldEdge.properties().toList().collect { prop ->" + "\n";
    script = script + "       g.E(newEdge.id()).property(prop.key(), prop.value()).next()" + "\n";
    script = script + "}}" + "\n";
    script = script + "//answer the maps" + "\n";
    script = script + "[vMapFull,eMapFull]" + "\n";
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, eMap, edgeIDsToSelect, endTime, json, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, results, vMap;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          if (json.status.code === 204) {
            return results = [];
          } else {
            results = json.result.data;
            nodeIDsToSelect = [];
            edgeIDsToSelect = [];
            if (window.UsingGraphSON3) {
              vMap = objectFromGraphSON3Map(results['@value'][0]);
              eMap = objectFromGraphSON3Map(results['@value'][1]);
              for (oldVID in vMap) {
                newV = vMap[oldVID];
                newV.type = 'vertex';
                newNode = {
                  id: String(newV.id['@value']),
                  label: labelForVertexGraphSON3(newV, Session.get('keyForNodeLabel')),
                  allowedToMoveX: true,
                  allowedToMoveY: true,
                  title: titleForElementGraphSON3(newV),
                  element: newV
                };
                window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
                oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
                window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
                nodeIDsToSelect.push(newNode.id);
              }
              for (oldEID in eMap) {
                newE = eMap[oldEID];
                newE.type = 'edge';
                newEdge = {
                  id: String(newE.id['@value']['relationId']),
                  label: newE.label,
                  from: newE.outV['@value'],
                  to: newE.inV['@value'],
                  title: titleForElementGraphSON3(newE),
                  element: newE
                };
                window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
                edgeIDsToSelect.push(newEdge.id);
              }
            } else {
              vMap = results[0];
              eMap = results[1];
              for (oldVID in vMap) {
                newV = vMap[oldVID];
                newNode = {
                  id: String(newV.id),
                  label: labelForVertex(newV, Session.get('keyForNodeLabel')),
                  allowedToMoveX: true,
                  allowedToMoveY: true,
                  title: titleForElement(newV),
                  element: newV
                };
                window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
                oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
                window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
                nodeIDsToSelect.push(newNode.id);
              }
              for (oldEID in eMap) {
                newE = eMap[oldEID];
                newEdge = {
                  id: String(newE.id),
                  label: newE.label,
                  from: newE.outV,
                  to: newE.inV,
                  title: titleForElement(newE),
                  element: newE
                };
                window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
                edgeIDsToSelect.push(newEdge.id);
              }
            }
            return window.visnetwork.setSelection({
              nodes: nodeIDsToSelect,
              edges: edgeIDsToSelect
            }, {
              unselectedAll: true,
              highlightEdges: false
            });
          }
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: bindings,
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Subgraph cloner', script, bindings, function(error, result) {
        var eMap, edgeIDsToSelect, newE, newEdge, newNode, newV, nodeIDsToSelect, oldEID, oldLoc, oldVID, vMap;
        if (result.success === true) {
          vMap = result.results[0];
          eMap = result.results[1];
          nodeIDsToSelect = [];
          edgeIDsToSelect = [];
          for (oldVID in vMap) {
            newV = vMap[oldVID];
            newNode = {
              id: String(newV.id),
              label: labelForVertex(newV, Session.get('keyForNodeLabel')),
              allowedToMoveX: true,
              allowedToMoveY: true,
              title: titleForElement(newV),
              element: newV
            };
            window.visnetwork.nodesHandler.body.data.nodes.add(newNode);
            oldLoc = (window.visnetwork.getPositions([oldVID]))[oldVID];
            window.visnetwork.moveNode(newNode.id, oldLoc.x + 50, oldLoc.y + 50);
            nodeIDsToSelect.push(newNode.id);
          }
          for (oldEID in eMap) {
            newE = eMap[oldEID];
            newEdge = {
              id: String(newE.id),
              label: newE.label,
              from: newE.outV,
              to: newE.inV,
              title: titleForElement(newE),
              element: newE
            };
            window.visnetwork.edgesHandler.body.data.edges.add(newEdge);
            edgeIDsToSelect.push(newEdge.id);
          }
          return window.visnetwork.setSelection({
            nodes: nodeIDsToSelect,
            edges: edgeIDsToSelect
          }, {
            unselectedAll: true,
            highlightEdges: false
          });
        } else {
          return alert("Selection cloning failed.  Nothing changed; " + script);
        }
      });
    }
  };

  addEdgeToGraph = function(edgeData, callback) {
    var j, label, labelSelectorHTML, labels, len, optionHTML;
    //edgeData is the vis.js object for its newly created edge on the client, {from: "id of node", to: "id of node"}
    labels = Session.get('edgeLabelSet');
    labelSelectorHTML = '<select onchange="window.updateVertexLabelBootBox(this)" >';
    optionHTML = '<option>Select an edge label</option>';
    labelSelectorHTML = labelSelectorHTML + optionHTML;
    for (j = 0, len = labels.length; j < len; j++) {
      label = labels[j];
      (function(label) {
        optionHTML = '<option>' + label + '</option>';
        return labelSelectorHTML = labelSelectorHTML + optionHTML;
      })(label);
    }
    labelSelectorHTML = labelSelectorHTML + '</select>';
    bootbox.prompt("<p>Enter the label for this new edge or choose one of these " + labelSelectorHTML + "</p><p>Edge labels are immutable (can't be changed), so choose wisely.</p>", function(result) {
      var request, script, startTime;
      label = result;
      if (label === null || label === "") {
        //alert "Edges must have labels, adding edge aborted"
        callback(null);
        return;
      }
      script = 'fromV = g.V("' + edgeData.from + '");';
      script = script + 'toV = g.V("' + edgeData.to + '");';
      script = script + 'e = fromV.addE("' + label + '").to(toV)';
      if (Session.get("usingWebSockets")) {
        window.socketToJanus.onmessage = function(msg) {
          var data, e, endTime, json, results;
          endTime = Date.now();
          data = msg.data;
          json = JSON.parse(data);
          if (json.status.code >= 500) {
            return alert("Error in processing Gremlin script: " + json.status.message);
          } else {
            if (json.status.code === 204) {
              results = [];
              edgeData = [];
            } else {
              if (window.UsingGraphSON3) {
                results = json.result.data['@value'];
                e = results[0]['@value'];
                e.type = 'edge';
                edgeData.id = String(e.id['@value']['relationId']);
                edgeData.from = String(e.outV['@value']);
                edgeData.to = String(e.inV['@value']);
                edgeData.label = e.label;
                edgeData.title = titleForElementGraphSON3(e);
              } else {
                results = json.result.data;
                e = results[0];
                edgeData.id = String(e.id);
                edgeData.from = String(e.outV);
                edgeData.to = String(e.inV);
                edgeData.label = e.label;
                edgeData.title = titleForElement(e);
              }
              edgeData.element = e;
            }
            // console.log edgeData
            getLabelSets();
            return callback(edgeData);
          }
        };
        request = {
          requestId: uuid.new(),
          op: "eval",
          processor: "",
          args: {
            gremlin: script,
            bindings: {},
            language: "gremlin-groovy"
          }
        };
        startTime = Date.now();
        return window.socketToJanus.send(JSON.stringify(request));
      } else {
        return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, function(error, result) {
          var e;
          if (result.success === true) {
            e = result.results[0];
            edgeData.id = String(e.id);
            edgeData.from = String(e.outV);
            edgeData.to = String(e.inV);
            edgeData.label = e.label;
            edgeData.title = titleForElement(e);
            edgeData.element = e;
            getLabelSets();
            return callback(edgeData);
          } else {
            return alert("Graph update failed.  Nothing changed");
          }
        });
      }
    });
    //update vertex label set in case new ones have been added
    return getLabelSets();
  };

  deleteSelected = function(selections, callback) {
    var bindings, edgeIDs, nodeIDs, request, script, startTime;
    //selections is { nodes:[], edges:[] }
    nodeIDs = selections.nodes;
    edgeIDs = selections.edges;
    script = 'nodeIDs.each {nodeID -> g.V(nodeID).drop()}; edgeIDs.each {edgeID -> g.V(edgeID).drop()}; ';
    bindings = {
      nodeIDs: nodeIDs,
      edgeIDs: edgeIDs
    };
    if (Session.get("usingWebSockets")) {
      window.socketToJanus.onmessage = function(msg) {
        var data, endTime, json;
        endTime = Date.now();
        data = msg.data;
        json = JSON.parse(data);
        if (json.status.code >= 500) {
          return alert("Error in processing Gremlin script: " + json.status.message);
        } else {
          return callback(selections);
        }
      };
      request = {
        requestId: uuid.new(),
        op: "eval",
        processor: "",
        args: {
          gremlin: script,
          bindings: {
            nodeIDs: nodeIDs,
            edgeIDs: edgeIDs
          },
          language: "gremlin-groovy"
        }
      };
      startTime = Date.now();
      return window.socketToJanus.send(JSON.stringify(request));
    } else {
      return Meteor.call('runScript', Session.get('userID'), Session.get('serverURL'), Session.get('tinkerPopVersion'), Session.get('graphName'), 'Built-in property updater', script, bindings, function(error, result) {
        if (result.success === true) {
          return callback(selections);
        } else {
          return alert("Graph update failed.  Nothing changed");
        }
      });
    }
  };

  userPropertiesForElement = function(element) {
    var j, key, len, props, ref;
    //this does not try to handle multivalue properties yet, only returns the first one
    props = {};
    if (element["properties"] !== void 0) {
      ref = _.keys(element.properties);
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        if (element.type === "vertex") {
          props[key] = element.properties[key][0].value; //edge properties aren't multivalued
        } else {
          props[key] = element.properties[key];
        }
      }
    }
    return props;
  };

  labelForVertex = function(vertex, keyForLabel) {
    var key, labelPrefix, nl, suffix;
    if (keyForLabel === void 0) {
      key = "null";
    } else {
      key = keyForLabel;
    }
    if (Session.get('useLabelPrefix')) {
      labelPrefix = vertex.label;
    } else {
      labelPrefix = "";
    }
    suffix = "";
    if (vertex[key] === void 0) {
      if (vertex.properties[key] !== void 0) {
        suffix = key + ": " + vertex.properties[key][0].value;
      } else {
        suffix = "";
        nl = "";
      }
    } else {
      suffix = key + ": " + vertex[key];
    }
    if (suffix !== "") {
      nl = '\n';
    } else {
      nl = "";
    }
    return labelPrefix + nl + suffix;
  };

  userPropertiesForElementGraphSON3 = function(element) {
    var j, key, len, props, ref, val;
    //this does not try to handle multivalue properties yet, only returns the first one
    props = {};
    if (element["properties"] !== void 0) {
      ref = _.keys(element.properties);
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        if (element.type === void 0) {
          debugger;
        }
        if (element.type === "vertex") {
          val = element.properties[key][0]['@value']['value'];
          if (val['@value']) {
            val = val['@value'];
          }
          if (typeof val === 'object') {
            val = geoshapeGraphSON3ToJava(val);
          }
          props[key] = val; //edge properties aren't multivalued
        } else {
          val = element.properties[key]['@value']['value'];
          if (val['@value']) {
            val = val['@value'];
          }
          if (typeof val === 'object') {
            val = geoshapeGraphSON3ToJava(val);
          }
          props[key] = val;
        }
      }
    }
    return props;
  };

  labelForVertexGraphSON3 = function(vertex, keyForLabel) {
    var key, labelPrefix, nl, suffix;
    if (keyForLabel === void 0) {
      key = "null";
    } else {
      key = keyForLabel;
    }
    if (Session.get('useLabelPrefix')) {
      labelPrefix = vertex.label;
    } else {
      labelPrefix = "";
    }
    suffix = "";
    if (vertex[key] === void 0) {
      if (vertex['properties'] && (vertex.properties[key] !== void 0)) {
        suffix = key + ": " + vertex.properties[key][0]['@value'];
      } else {
        suffix = "";
        nl = "";
      }
    } else {
      suffix = key + ": " + vertex[key];
    }
    if (suffix !== "") {
      nl = '\n';
    } else {
      nl = "";
    }
    return labelPrefix + nl + suffix;
  };

  allKeysInVerts = function(verts) {
    var allKeys, j, k, l, len, len1, ref, v;
    //answer the collection of all unique vertex keys in verts
    //include id, label, and properties, omit type (edge/vertex)
    allKeys = ['id', 'label'];
    for (j = 0, len = verts.length; j < len; j++) {
      v = verts[j];
      ref = Object.keys(v.properties);
      for (l = 0, len1 = ref.length; l < len1; l++) {
        k = ref[l];
        allKeys.push(k);
      }
    }
    return _.uniq(allKeys);
  };

  window.updateEdgeColors = function() {
    var conf, edge, j, len, ref, results1;
    conf = window.visnetwork.configurator.moduleOptions;
    ref = _.values(window.visnetwork.edgesHandler.body.data.edges._data);
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      edge = ref[j];
      console.log(edge);
      if (edge.color === void 0) {
        edge.color = {};
      }
      edge.color = conf.edges.color.color;
      edge.color.highlight = conf.edges.color.highlight;
      edge.color.hover = conf.edges.color.hover;
      edge.color.opacity = conf.edges.color.opacity;
      edge.color.inherit = conf.edges.color.inherit;
      results1.push(window.visnetwork.edgesHandler.body.data.edges.update([edge], []));
    }
    return results1;
  };

  window.getElementTypeFromID = function(id) {
    var edge, node;
    node = window.visnetwork.nodesHandler.body.data.nodes._data[id];
    edge = window.visnetwork.edgesHandler.body.data.edges._data[id];
    if (node) {
      return "vertex";
    }
    if (edge) {
      return "edge";
    }
    return null;
  };

  window.renderGraph = function() {
    Session.set('graphRenderingStatus', 'Rendering...');
    //  graph = Session.get 'graphToShow'
    return Session.set('renderStartTime', moment().toDate());
  };

  //vn = new vis.DataSet(graph.nodes)
  //ve = new vis.DataSet(graph.edges)
  //window.visnetwork.setData {nodes: vn, edges: ve}
  window.setUpVis = function() {
    var canvas, config, container, ctx, data, defaultOptions, drag, drawingSurfaceImageData, getStartToEnd, options, rect, restoreDrawingSurface, saveDrawingSurface, selectEdges, selectNodes, selectNodesFromHighlight, updateNodelabels, visOptions;
    this.find('.results-vis')._uihooks;
    container = document.getElementById('mynetwork');
    config = document.getElementById('vis-config');
    $(config).hide();
    visOptions = Session.get('visOptions');
    defaultOptions = {
      interaction: {
        hover: true,
        navigationButtons: true,
        multiselect: true,
        dragView: true,
        selectConnectedEdges: false
      },
      manipulation: {
        addNode: function(nodeData, callback) {
          return addVertToGraph(nodeData, callback);
        },
        addEdge: function(edgeData, callback) {
          return addEdgeToGraph(edgeData, callback);
        },
        deleteNode: function(selections, callback) {
          return deleteSelected(selections, callback);
        },
        deleteEdge: function(selections, callback) {
          return deleteSelected(selections, callback);
        },
        editNode: function(node, callback) {
          window.popupPropertyEditor(window.visnetwork.nodesHandler.body.data.nodes.get(node.id), "vertex");
          return callback();
        },
        editEdge: false
      },
      configure: {
        enabled: true,
        container: config,
        showButton: true
      },
      physics: true,
      nodes: {
        shape: "box",
        labelHighlightBold: true,
        font: {
          face: 'arial'
        },
        hidden: false,
        borderWidth: 1,
        color: {
          hover: {
            border: '#ffff00',
            background: '#0066cc'
          },
          highlight: {
            border: '#ff0000',
            background: '#ffff00'
          }
        }
      },
      edges: {
        hidden: false,
        arrows: {
          to: {
            enabled: true,
            scaleFactor: 0.5
          }
        },
        color: {
          highlight: '#ff0000',
          hover: '#0066cc'
        }
      }
    };
    if (visOptions === void 0) {
      options = defaultOptions;
    } else {
      options = visOptions;
    }
    data = [];
    console.log("installing window.visnetwork");
    window.visnetwork = new vis.Network(container, data, options);
    window.visnetwork.on('afterDrawing', function(params) {
      var d, graph, renderStopTime;
      if ((Session.get("firstRender")) === 1) {
        renderStopTime = moment();
        d = moment.duration(Math.round((renderStopTime - moment(Session.get('renderStartTime'))) * 1000) / 1000);
        Session.set('elapsedRenderTime', durationToString(d));
        graph = Session.get('graphToShow');
        if (graph.nodes.length > 0) {
          Session.set('graphRenderingStatus', 'Finished ' + graph.nodes.length + 'V, ' + graph.edges.length + 'E');
        }
      }
      return Session.set("firstRender", (Session.get("firstRender")) + 1);
    });
    window.visnetwork.on('doubleClick', function(params) { // open a dialog for the selected element
      var element, elementType;
      if (params.nodes.length !== 0) { // then a node was doubleClicked
        elementType = 'vertex';
        element = window.visnetwork.nodesHandler.body.data.nodes.get(params.nodes[0]);
      } else {
        if (params.edges.length === 1) { // then an edge was doubleClicked
          elementType = 'edge';
          element = window.visnetwork.edgesHandler.body.data.edges.get(params.edges[0]);
        } else {
          return;
        }
      }
      return window.popupPropertyEditor(element, elementType);
    });
    $('.context-cloneSelections').click(function() {
      var params;
      params = window.visnetwork.getSelection();
      return cloneSelections(params.nodes, params.edges);
    });
    $('.context-deleteSelections').click(function() {
      var params;
      params = window.visnetwork.getSelection();
      return bootbox.confirm({
        message: "Do you really want to delete " + params.nodes.length + " vertices and " + params.edges.length + " edges?  (no undo)",
        buttons: {
          confirm: {
            label: 'Yes, delete them',
            className: 'btn-success'
          },
          cancel: {
            label: "No, don't delete anything",
            className: 'btn-danger'
          }
        },
        callback: function(result) {
          if (result) {
            return deleteSelections(params.nodes, params.edges);
          }
        }
      });
    });
    $('.context-expandSelections').click(function() {
      return expandSelections();
    });
    $('.context-expandSelections5').click(function() {
      return expandSelections5();
    });
    $('.context-dropSelections').click(function() {
      return dropSelections();
    });
    $('.context-growSelections').click(function() {
      return growSelections();
    });
    $('.context-selectAll').click(function() {
      return selectAll();
    });
    $('.context-selectNone').click(function() {
      return selectNone();
    });
    $('.context-invertSelections').click(function() {
      return invertSelections();
    });
    $('.context-hideSelections1').click(function() {
      return hideSelections1();
    });
    $('.context-unhideSelections1').click(function() {
      return unhideSelections1();
    });
    $('.context-spawnHidden1').click(function() {
      return spawnHidden1();
    });
    $('.context-hideSelections2').click(function() {
      return hideSelections2();
    });
    $('.context-unhideSelections2').click(function() {
      return unhideSelections2();
    });
    $('.context-spawnHidden2').click(function() {
      return spawnHidden2();
    });
    $('.context-hideSelections3').click(function() {
      return hideSelections3();
    });
    $('.context-unhideSelections3').click(function() {
      return unhideSelections3();
    });
    $('.context-spawnHidden3').click(function() {
      return spawnHidden3();
    });
    $('.context-hideSelections4').click(function() {
      return hideSelections4();
    });
    $('.context-unhideSelections4').click(function() {
      return unhideSelections4();
    });
    $('.context-spawnHidden4').click(function() {
      return spawnHidden4();
    });
    $('.context-inspectSelections').click(function() {
      return inspectSelections();
    });
    $('.context-inspectNone').click(function() {
      return inspectNone();
    });
    $('.context-pinSelections').click(function() {
      return pinSelections();
    });
    $('.context-unpinSelections').click(function() {
      return unpinSelections();
    });
    $('.context-generateJSONBindingsForSelections').click(function() {
      return generateJSONBindingsForSelections();
    });
    $('.context-shareGremlinCodeForIngestion').click(function() {
      return shareGremlinCodeForIngestion();
    });
    $('.context-inputGremlinCodeForIngestion').click(function() {
      return inputGremlinCodeForIngestion();
    });
    $('.context-spawnToQuikVis').click(function() {
      return spawnToQuikVis();
    });
    $('.context-spawnAllToQuikVis').click(function() {
      return spawnAllToQuikVis();
    });
    window.popupPropertyEditor = function(element, elementType) {
      var div, html, id, title;
      id = element.element.id;
      if (id['@value']) {
        html = popupDialogForElementGraphSON3(element, elementType);
        if (elementType === 'vertex') {
          id = id['@value'];
        } else {
          id = id['@value']['relationId'];
        }
      } else {
        html = popupDialogForElement(element, elementType);
      }
      title = elementType + ': ' + id;
      div = document.createElement('div');
      div.class = 'doubleClick-dialog';
      div.innerHTML = html;
      $(".vis-network").append(div);
      $(div).dialog({
        title: title,
        resizable: true,
        width: 500,
        height: "auto",
        beforeClose: function(event, ui) {
          return $(".propTableForElementID" + id).remove();
        }
      });
      $('.element-deleteProperty' + id).click(function() {
        $(this.parentNode.parentNode.parentNode.parentNode.parentNode).next().show();
        return this.parentNode.parentNode.parentNode.remove();
      });
      $('.element-copyProperty' + id).click(function() {
        var key, type, value;
        key = this.parentNode.parentNode.parentNode.children[0].innerText.slice(0, -1);
        value = this.parentNode.parentNode.parentNode.children[1].children[0].value;
        if (window.UsingGraphSON3) {
          type = this.parentNode.parentNode.parentNode.children[2].children[0].value;
          Session.set("propCopyBuffer", {
            key: key,
            value: value,
            type: type
          });
          return console.log("copied ", key, value, type);
        } else {
          Session.set("propCopyBuffer", {
            key: key,
            value: value
          });
          return console.log("copied ", key, value);
        }
      });
      $('.element-pasteProperty' + id).click(function() {
        var copyPropButton, deletePropButton, key, prop, tr, type, typeSelector, value;
        prop = Session.get("propCopyBuffer");
        elementType = window.getElementTypeFromID(id);
        if (prop) {
          key = prop.key;
          value = prop.value;
          if (window.UsingGraphSON3) {
            type = prop.type;
          }
          $(".propTableForElementID" + id).next().show();
          deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
          copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
          if (window.UsingGraphSON3) {
            cacheOriginalPropertyTypeGraphSON3(elementType, id, key, type);
            typeSelector = buildTypeSelectorHTMLGraphSON3(id, key, type, elementType, 'disabled');
            tr = '<tr><td>' + key + ':  </td><td style="width:100%"><input style="width:100%" type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><td style="width:100%" id="' + id + '" value="' + elementType + '" name="' + key + '">' + typeSelector + deletePropButton + copyPropButton + '</td></tr>';
          } else {
            tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'button.commitButtonForElementID' + id + '\').show()"></td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
          }
          $(".propTableForElementID" + id).append(tr);
          return $('.element-deleteProperty' + id).click(function() {
            $(".propTableForElementID" + id).next().show();
            return this.parentNode.parentNode.parentNode.remove();
          });
        } else {
          return alert("Nothing to paste, try copying a property first");
        }
      });
      $('.element-log' + id).click(function() {
        var edge, node;
        node = window.visnetwork.nodesHandler.body.data.nodes.get(id);
        if (node) {
          return console.log(node);
        } else {
          edge = window.visnetwork.edgesHandler.body.data.edges.get(id);
          return console.log(edge);
        }
      });
      $('.clone-vertex' + id).click(function() {
        return cloneVertToGraph(id);
      });
      $('.clone-edge' + id).click(function() {
        return cloneElements({
          "nodes": [],
          "edges": [id]
        });
      });
      $('.element-addProperty' + id).click(function() {
        return bootbox.dialog({
          title: "Enter a name for the new property",
          message: '<div class="row">  ' + '<div class="col-md-12"> ' + '<form class="form-horizontal"> ' + '<div class="form-group"> ' + '<label class="col-md-4 control-label" for="name">Key</label> ' + '<div class="col-md-4"> ' + '<input id="key' + id + '" name="key" type="text" placeholder="aPropertyName" class="form-control input-md"> ' + '</div> ' + '<label class="col-md-4 control-label" for="name">Value</label> ' + '<div class="col-md-4"> ' + '<input id="value' + id + '" name="value" type="text" placeholder="someValue" class="form-control input-md"> ' + '</div> ' + '</form> </div>  </div>',
          buttons: {
            confirm: {
              label: "Save",
              className: "btn-success",
              callback: function() {
                var copyPropButton, deletePropButton, key, tr, value;
                key = $('#key' + id + '').val();
                value = $('#value' + id + '').val();
                if (key === "id" | key === "label" | key === "type") {
                  return window.alert('Reserved property name disallowed: ' + key);
                } else {
                  $(".propTableForElementID" + id).next().show();
                  deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
                  copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
                  tr = '<tr><td>' + key + ':  </td><td><input type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'button.commitButtonForElementID' + id + '\').show()"></td><th style="width:50" id="' + id + '" value="' + elementType + '" name="' + key + '">' + deletePropButton + copyPropButton + '</th></tr>';
                  $(".propTableForElementID" + id).append(tr);
                  return $('.element-deleteProperty' + id).click(function() {
                    $(".propTableForElementID" + id).next().show();
                    return this.parentNode.parentNode.parentNode.remove();
                  });
                }
              }
            }
          }
        });
      });
      $('.element-addVertexPropertyGraphSON3' + id).click(function() {
        return bootbox.dialog({
          title: "Enter a name for the new property",
          message: '<div class="row">  ' + '<div class="col-md-12"> ' + '<form class="form-horizontal"> ' + '<div class="form-group"> ' + '<label class="col-md-4 control-label" for="name">Key</label> ' + '<div class="col-md-4"> ' + '<input id="key' + id + '" name="key" type="text" placeholder="aPropertyName" class="form-control input-md"> ' + '</div> ' + '<label class="col-md-4 control-label" for="name">Value</label> ' + '<div class="col-md-4"> ' + '<input id="value' + id + '" name="value" type="text" placeholder="someValue" class="form-control input-md"> ' + '</div> ' + '</form> </div>  </div>',
          buttons: {
            confirm: {
              label: "Save",
              className: "btn-success",
              callback: function() {
                var copyPropButton, deletePropButton, key, tr, typeSelector, value;
                key = $('#key' + id + '').val();
                value = $('#value' + id + '').val();
                if (key === "id" | key === "label" | key === "type") {
                  return window.alert('Reserved property name disallowed: ' + key);
                } else {
                  $(".propTableForElementID" + id).next().show();
                  deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
                  copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
                  cacheOriginalPropertyTypeGraphSON3('vertex', id, key, 'String');
                  typeSelector = buildTypeSelectorHTMLGraphSON3(id, key, 'String', 'vertex', '');
                  tr = '<tr><td>' + key + ':  </td><td style="width:100%"><input style="width:100%" type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><td style="width:100%" id="' + id + '" value="' + elementType + '" name="' + key + '">' + typeSelector + deletePropButton + copyPropButton + '</td></tr>';
                  //                tr = '<tr><td>'+key+':  </td><td><input type="text" class="propForElementID'+id+'" name='+key+' value="'+value+'" oninput="$(\'button.commitButtonForElementID'+id+'\').show()"></td><th style="width:50" id="'+id+'" value="'+elementType+'" name="'+key+'">'+deletePropButton+copyPropButton+'</th></tr>'
                  $(".propTableForElementID" + id).append(tr);
                  return $('.element-deleteProperty' + id).click(function() {
                    $(".propTableForElementID" + id).next().show();
                    return this.parentNode.parentNode.parentNode.remove();
                  });
                }
              }
            }
          }
        });
      });
      return $('.element-addEdgePropertyGraphSON3' + id).click(function() {
        return bootbox.dialog({
          title: "Enter a name for the new property",
          message: '<div class="row">  ' + '<div class="col-md-12"> ' + '<form class="form-horizontal"> ' + '<div class="form-group"> ' + '<label class="col-md-4 control-label" for="name">Key</label> ' + '<div class="col-md-4"> ' + '<input id="key' + id + '" name="key" type="text" placeholder="aPropertyName" class="form-control input-md"> ' + '</div> ' + '<label class="col-md-4 control-label" for="name">Value</label> ' + '<div class="col-md-4"> ' + '<input id="value' + id + '" name="value" type="text" placeholder="someValue" class="form-control input-md"> ' + '</div> ' + '</form> </div>  </div>',
          buttons: {
            confirm: {
              label: "Save",
              className: "btn-success",
              callback: function() {
                var copyPropButton, deletePropButton, key, tr, typeSelector, value;
                key = $('#key' + id + '').val();
                value = $('#value' + id + '').val();
                if (key === "id" | key === "label" | key === "type") {
                  return window.alert('Reserved property name disallowed: ' + key);
                } else {
                  $(".propTableForElementID" + id).next().show();
                  deletePropButton = '<a href="#" class="btn btn-default" title="Delete property"><span class="glyphicon glyphicon-minus element-deleteProperty' + id + '"></span></a>';
                  copyPropButton = '<a href="#" class="btn btn-default" title="Copy property"><span class="glyphicon glyphicon-copy element-copyProperty' + id + '"></span></a>';
                  cacheOriginalPropertyTypeGraphSON3('edge', id, key, 'String');
                  typeSelector = buildTypeSelectorHTMLGraphSON3(id, key, 'String', 'edge', '');
                  tr = '<tr><td>' + key + ':  </td><td style="width:100%"><input style="width:100%" type="text" class="propForElementID' + id + '" name=' + key + ' value="' + value + '" oninput="$(\'.commitButtonForElementID' + id + '\').show()"></td><td style="width:100%" id="' + id + '" value="' + elementType + '" name="' + key + '">' + typeSelector + deletePropButton + copyPropButton + '</td></tr>';
                  //                tr = '<tr><td>'+key+':  </td><td><input type="text" class="propForElementID'+id+'" name='+key+' value="'+value+'" oninput="$(\'button.commitButtonForElementID'+id+'\').show()"></td><th style="width:50" id="'+id+'" value="'+elementType+'" name="'+key+'">'+deletePropButton+copyPropButton+'</th></tr>'
                  $(".propTableForElementID" + id).append(tr);
                  return $('.element-deleteProperty' + id).click(function() {
                    $(".propTableForElementID" + id).next().show();
                    return this.parentNode.parentNode.parentNode.remove();
                  });
                }
              }
            }
          }
        });
      });
    };
    $(".results-graph-fit").click(function() {
      return window.visnetwork.fit();
    });
    //------------------drag multiselect functions----------------------------
    rect = {};
    drag = false;
    canvas = window.visnetwork.canvas.frame.canvas;
    ctx = canvas.getContext('2d');
    drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    saveDrawingSurface = function() {
      drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    };
    restoreDrawingSurface = function() {
      ctx.putImageData(drawingSurfaceImageData, 0, 0);
    };
    selectNodesFromHighlight = function() {
      var allNodes, curNode, i, nodePosition, nodeXY, nodesIdInDrawing, xRange, yRange;
      nodesIdInDrawing = Session.get('selectedNodes');
      xRange = getStartToEnd(rect.startX, rect.w);
      yRange = getStartToEnd(rect.startY, rect.h);
      allNodes = window.visnetwork.nodesHandler.body.data.nodes.get();
      i = 0;
      while (i < allNodes.length) {
        curNode = allNodes[i];
        nodePosition = window.visnetwork.getPositions([curNode.id]);
        nodeXY = window.visnetwork.canvasToDOM({
          x: nodePosition[curNode.id].x,
          y: nodePosition[curNode.id].y
        });
        if (xRange.start <= nodeXY.x && nodeXY.x <= xRange.end && yRange.start <= nodeXY.y && nodeXY.y <= yRange.end) {
          nodesIdInDrawing.push(curNode.id);
        }
        i++;
      }
      window.visnetwork.selectNodes(nodesIdInDrawing);
    };
    getStartToEnd = function(start, theLen) {
      var ret;
      if (theLen > 0) {
        ret = {
          start: start,
          end: start + theLen
        };
      } else {
        ret = {
          start: start + theLen,
          end: start
        };
      }
      return ret;
    };
    container = $("#mynetwork");
    container.on('mousemove', function(e) {
      if (drag) {
        restoreDrawingSurface();
        rect.w = e.pageX - this.offsetLeft - rect.startX;
        rect.h = e.pageY - this.offsetTop - rect.startY;
        ctx.setLineDash([5]);
        ctx.strokeStyle = 'rgb(0, 102, 0)';
        ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      }
    });
    container.on('mousedown', function(e) {
      var currentSelections, that;
      Session.set('selectedNodes', []);
      if (e.button === 2) {
        if (e.shiftKey) {
          currentSelections = window.visnetwork.getSelectedNodes();
          Session.set('selectedNodes', currentSelections);
        }
        saveDrawingSurface();
        that = this;
        rect.startX = e.pageX - this.offsetLeft;
        rect.startY = e.pageY - this.offsetTop;
        drag = true;
        container[0].style.cursor = 'crosshair';
      }
    });
    container.on('mouseup', function(e) {
      if (e.button === 2) {
        restoreDrawingSurface();
        drag = false;
        container[0].style.cursor = 'default';
        selectNodesFromHighlight();
      }
    });
    document.body.oncontextmenu = function() {
      return false;
    };
    //-------------- Viz option controls --------------------
    $(".vis-options-node-hideShow").prop('checked', true);
    $(".vis-options-node-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-node-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        nodes: {
          hidden: newState
        }
      });
    });
    $(".vis-options-edge-hideShow").prop('checked', true);
    $(".vis-options-edge-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-edge-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        edges: {
          hidden: newState
        }
      });
    });
    $(".vis-options-physics-toggle").prop('checked', true);
    $(".vis-options-physics-toggle").change(function() {
      var state;
      state = $(".vis-options-physics-toggle").prop('checked');
      return window.visnetwork.setOptions({
        physics: state
      });
    });
    $('.all-settings').click(function(evt) {
      return $('#vis-config').dialog({
        title: 'Visualization Options',
        resizable: true,
        width: 500,
        height: 300
      });
    });
    //-------------- Node Label Selector --------------------
    $("#nodeLabelProperty").change(function() {
      return updateNodelabels();
    });
    updateNodelabels = function() {
      var key, nodes, selections;
      key = $("#nodeLabelProperty").val();
      Session.set('keyForNodeLabel', key);
      nodes = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
      window.visnetwork.stopSimulation();
      selections = (window.visnetwork.getSelection()).nodes;
      if (!selections.length) { //no selections, apply to all nodes
        nodes.forEach(function(node) {
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label // apply to selected nodes only
          });
        });
      } else {
        selections.forEach(function(nodeID) {
          var node;
          node = nodes.get(nodeID);
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      }
      return window.visnetwork.startSimulation();
    };
    $(".useLabelPrefix").prop('checked', true);
    Session.set('useLabelPrefix', true);
    $(".useLabelPrefix").change(function() {
      var state;
      state = $(".useLabelPrefix").prop('checked');
      Session.set('useLabelPrefix', state);
      return updateNodelabels();
    });
    //------------------Select IF support
    $("#nodeLabelSelector").change(function() {
      var sel;
      sel = $("#nodeLabelSelector").val();
      if (sel === 'all vertices') {
        $('#elementSelector').val('{"type": "vertex"}');
      } else {
        if (sel === 'all edges') {
          $('#elementSelector').val('{"type": "edge"}');
        } else {
          $('#elementSelector').val('"' + $("#nodeLabelSelector").val() + '"');
        }
      }
      return $('#elementSelector').trigger('input');
    });
    Session.set('elementSelector', null); // null means select nothing
    window.updateSelectedElements = function(ctxt) {
      var error, selectedEdges, selectedNodes, selector;
      Session.set('elementSelector', ctxt);
      try {
        selector = JSON.parse(Session.get('elementSelector'));
        $('#elementSelector')[0].style.color = 'black';
      } catch (error1) {
        error = error1;
        $('#elementSelector')[0].style.color = 'red'; // signal a syntax error with red text
        return;
      }
      selectedNodes = selectNodes(selector, window.visnetwork.body.data.nodes._data);
      selectedEdges = selectEdges(selector, window.visnetwork.body.data.edges._data);
      return window.visnetwork.setSelection({
        nodes: selectedNodes,
        edges: selectedEdges
      }, {
        unselectedAll: true,
        highlightEdges: false
      });
    };
    selectNodes = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, m, obj, possibleProps, possibleValues, props, selected;
      // options for selection query:   null, id#, labelString, {key:val, key:val...}, [query,query,...]
      selected = [];
      if (selector === null) { // select nothing
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) { // string label selector, convert to object
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) { // select all elements with these properties
        possibleProps = (function() {
          var j, len, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            each = ref[j];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: each.element.properties
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (j = 0, len = possibleProps.length; j < len; j++) {
          props = possibleProps[j];
          obj = {
            id: props.id,
            label: props.label,
            type: props.type
          };
          (function() {
            var l, len1, ref, results1;
            ref = _.keys(props.props);
            results1 = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              key = ref[l];
              results1.push(obj[key] = props.props[key][0].value);
            }
            return results1;
          })();
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (l = 0, len1 = found.length; l < len1; l++) {
          f = found[l];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) { // an array of selectors
        for (m = 0, len2 = selector.length; m < len2; m++) {
          each = selector[m];
          selected.push(selectNodes(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    selectEdges = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, len3, m, n, obj, possibleProps, possibleValues, props, selected;
      // options for selection query:   null, id#, labelString, {key:val, key:val...}, [query,query,...]
      selected = [];
      if (selector === null) { // select nothing
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) { // string label selector, convert to object
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector) === 232) { // select all elements with these properties
        possibleValues = _.values(possibles);
        found = _.where(possibleValues, selector);
        for (j = 0, len = found.length; j < len; j++) {
          f = found[j];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isPlainObject(selector)) { // select all elements with these properties
        possibleProps = (function() {
          var l, len1, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            each = ref[l];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: (each.element.properties ? each.element.properties : {})
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (l = 0, len1 = possibleProps.length; l < len1; l++) {
          props = possibleProps[l];
          obj = {
            id: props.id,
            label: props.label,
            type: 'edge'
          };
          (function() {
            var len2, m, ref, results1;
            ref = _.keys(props.props);
            results1 = [];
            for (m = 0, len2 = ref.length; m < len2; m++) {
              key = ref[m];
              results1.push(obj[key] = props.props[key]);
            }
            return results1;
          })();
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (m = 0, len2 = found.length; m < len2; m++) {
          f = found[m];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) { // an array of selectors
        for (n = 0, len3 = selector.length; n < len3; n++) {
          each = selector[n];
          selected.push(selectEdges(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    return;
    $(".results-graph-fit").click(function() {
      return window.visnetwork.fit();
    });
    //------------------drag multiselect functions----------------------------
    rect = {};
    drag = false;
    canvas = window.visnetwork.canvas.frame.canvas;
    ctx = canvas.getContext('2d');
    drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    saveDrawingSurface = function() {
      drawingSurfaceImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    };
    restoreDrawingSurface = function() {
      ctx.putImageData(drawingSurfaceImageData, 0, 0);
    };
    selectNodesFromHighlight = function() {
      var allNodes, curNode, i, nodePosition, nodeXY, nodesIdInDrawing, xRange, yRange;
      nodesIdInDrawing = Session.get('selectedNodes');
      xRange = getStartToEnd(rect.startX, rect.w);
      yRange = getStartToEnd(rect.startY, rect.h);
      allNodes = window.visnetwork.nodesHandler.body.data.nodes.get();
      i = 0;
      while (i < allNodes.length) {
        curNode = allNodes[i];
        nodePosition = window.visnetwork.getPositions([curNode.id]);
        nodeXY = window.visnetwork.canvasToDOM({
          x: nodePosition[curNode.id].x,
          y: nodePosition[curNode.id].y
        });
        if (xRange.start <= nodeXY.x && nodeXY.x <= xRange.end && yRange.start <= nodeXY.y && nodeXY.y <= yRange.end) {
          nodesIdInDrawing.push(curNode.id);
        }
        i++;
      }
      window.visnetwork.selectNodes(nodesIdInDrawing);
    };
    getStartToEnd = function(start, theLen) {
      var ret;
      if (theLen > 0) {
        ret = {
          start: start,
          end: start + theLen
        };
      } else {
        ret = {
          start: start + theLen,
          end: start
        };
      }
      return ret;
    };
    container = $("#mynetwork");
    container.on('mousemove', function(e) {
      if (drag) {
        restoreDrawingSurface();
        rect.w = e.pageX - this.offsetLeft - rect.startX;
        rect.h = e.pageY - this.offsetTop - rect.startY;
        ctx.setLineDash([5]);
        ctx.strokeStyle = 'rgb(0, 102, 0)';
        ctx.strokeRect(rect.startX, rect.startY, rect.w, rect.h);
        ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
        ctx.fillRect(rect.startX, rect.startY, rect.w, rect.h);
      }
    });
    container.on('mousedown', function(e) {
      var currentSelections, that;
      Session.set('selectedNodes', []);
      if (e.button === 2) {
        if (e.shiftKey) {
          currentSelections = window.visnetwork.getSelectedNodes();
          Session.set('selectedNodes', currentSelections);
        }
        saveDrawingSurface();
        that = this;
        rect.startX = e.pageX - this.offsetLeft;
        rect.startY = e.pageY - this.offsetTop;
        drag = true;
        container[0].style.cursor = 'crosshair';
      }
    });
    container.on('mouseup', function(e) {
      if (e.button === 2) {
        restoreDrawingSurface();
        drag = false;
        container[0].style.cursor = 'default';
        selectNodesFromHighlight();
      }
    });
    document.body.oncontextmenu = function() {
      return false;
    };
    //-------------- Viz option controls --------------------
    $(".vis-options-node-hideShow").prop('checked', true);
    $(".vis-options-node-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-node-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        nodes: {
          hidden: newState
        }
      });
    });
    $(".vis-options-edge-hideShow").prop('checked', true);
    $(".vis-options-edge-hideShow").change(function() {
      var newState, oldState;
      oldState = $(".vis-options-edge-hideShow").prop('checked');
      newState = !oldState;
      return window.visnetwork.setOptions({
        edges: {
          hidden: newState
        }
      });
    });
    $(".vis-options-physics-toggle").prop('checked', true);
    $(".vis-options-physics-toggle").change(function() {
      var state;
      state = $(".vis-options-physics-toggle").prop('checked');
      return window.visnetwork.setOptions({
        physics: state
      });
    });
    $('.all-settings').click(function(evt) {
      return $('#vis-config').dialog({
        title: 'Visualization Options',
        resizable: true,
        width: 500,
        height: 300
      });
    });
    //-------------- Node Label Selector --------------------
    $("#nodeLabelProperty").change(function() {
      return updateNodelabels();
    });
    updateNodelabels = function() {
      var key, nodes, selections;
      key = $("#nodeLabelProperty").val();
      Session.set('keyForNodeLabel', key);
      nodes = window.visnetwork.nodesHandler.body.data.nodes.getDataSet();
      window.visnetwork.stopSimulation();
      selections = (window.visnetwork.getSelection()).nodes;
      if (!selections.length) { //no selections, apply to all nodes
        nodes.forEach(function(node) {
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label // apply to selected nodes only
          });
        });
      } else {
        selections.forEach(function(nodeID) {
          var node;
          node = nodes.get(nodeID);
          node.label = labelForVertex(node.element, key);
          return nodes.update({
            id: node.id,
            label: node.label
          });
        });
      }
      return window.visnetwork.startSimulation();
    };
    $(".useLabelPrefix").prop('checked', true);
    Session.set('useLabelPrefix', true);
    $(".useLabelPrefix").change(function() {
      var state;
      state = $(".useLabelPrefix").prop('checked');
      Session.set('useLabelPrefix', state);
      return updateNodelabels();
    });
    //------------------Select IF support
    $("#nodeLabelSelector").change(function() {
      $('#elementSelector').val('"' + $("#nodeLabelSelector").val() + '"');
      return $('#elementSelector').trigger('input');
    });
    Session.set('elementSelector', null); // null means select nothing
    window.updateSelectedElements = function(ctxt) {
      var error, selectedEdges, selectedNodes, selector;
      Session.set('elementSelector', ctxt);
      try {
        selector = JSON.parse(Session.get('elementSelector'));
        $('#elementSelector')[0].style.color = 'black';
      } catch (error1) {
        error = error1;
        $('#elementSelector')[0].style.color = 'red'; // signal a syntax error with red text
        return;
      }
      selectedNodes = selectNodes(selector, window.visnetwork.body.data.nodes._data);
      selectedEdges = selectEdges(selector, window.visnetwork.body.data.edges._data);
      return window.visnetwork.setSelection({
        nodes: selectedNodes,
        edges: selectedEdges
      }, {
        unselectedAll: true,
        highlightEdges: false
      });
    };
    selectNodes = function(selector, possibles) {
      var each, f, found, j, key, l, len, len1, len2, m, obj, possibleProps, possibleValues, props, selected;
      // options for selection query:   null, id#, labelString, {key:val, key:val...}, [query,query,...]
      selected = [];
      if (selector === null) { // select nothing
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) { // string label selector, convert to object
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) { // select all elements with these properties
        possibleProps = (function() {
          var j, len, ref, results1;
          ref = _.values(possibles);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            each = ref[j];
            results1.push({
              id: each.id,
              label: each.element.label,
              type: each.element.type,
              props: each.element.properties
            });
          }
          return results1;
        })();
        possibleValues = [];
        for (j = 0, len = possibleProps.length; j < len; j++) {
          props = possibleProps[j];
          obj = {
            id: props.id,
            label: props.label,
            type: props.type
          };
          (function() {
            var l, len1, ref, results1;
            ref = _.keys(props.props);
            results1 = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              key = ref[l];
              results1.push(obj[key] = props.props[key][0].value);
            }
            return results1;
          })();
          possibleValues.push(obj);
        }
        found = _.where(possibleValues, selector);
        for (l = 0, len1 = found.length; l < len1; l++) {
          f = found[l];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) { // an array of selectors
        for (m = 0, len2 = selector.length; m < len2; m++) {
          each = selector[m];
          selected.push(selectNodes(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
    selectEdges = function(selector, possibles) {
      var each, f, found, j, l, len, len1, possibleValues, selected;
      // options for selection query:   null, id#, labelString, {key:val, key:val...}, [query,query,...]
      selected = [];
      if (selector === null) { // select nothing
        return selected;
      }
      if ($.isNumeric(selector) && possibles[selector]) {
        selected.push(selector);
        return selected;
      }
      if (_.isString(selector)) { // string label selector, convert to object
        selector = {
          label: selector
        };
      }
      if ($.isPlainObject(selector)) { // select all elements with these properties
        possibleValues = _.values(possibles);
        found = _.where(possibleValues, selector);
        for (j = 0, len = found.length; j < len; j++) {
          f = found[j];
          selected.push(f.id);
        }
        return selected;
      }
      if ($.isArray(selector)) { // an array of selectors
        for (l = 0, len1 = selector.length; l < len1; l++) {
          each = selector[l];
          selected.push(selectEdges(each, possibles));
        }
        selected = _.flatten(selected);
        return selected;
      }
      return selected;
    };
  };

  processResults = function(results, success, queryTime) {
    var d;
    if (window.resultsEditor) {
      window.resultsEditor.set(results);
    }
    Session.set('scriptResult', results);
    Session.set('runStatus', success);
    d = moment.duration(Math.round(queryTime * 1000) / 1000);
    Session.set('queryTime', window.durationToString(d));
    d = moment.duration(Math.round((moment() - moment(Session.get('startTime'))) * 1000) / 1000);
    Session.set('elapsedTime', window.durationToString(d));
    determineGraphToShow();
    if (((Session.get('graphToShow')).nodes.length === 0) && ((Session.get('graphToShow')).edges.length === 0)) {
      Session.set('graphRenderingStatus', 'No graph in result');
    } else {
      Session.set('graphRenderingStatus', 'Ready');
      if (Session.get('drawGraphResult') === true) {
        Session.set('drawButtonPressed', true);
        Session.set('graphRenderingStatus', 'Rendering...');
        Session.set('elapsedRenderTime', 'Timing...');
        randomizeLayout();
        renderGraph();
      }
    }
  };

  selectNeighborsToAdd = function(currentSelectedNodeIDs, currentSelectedEdgeIDs, allV, allE) {
    var box;
    box = bootbox.dialog({
      title: 'Select neighboring vertices to add to local graph',
      message: 'hello',
      buttons: {
        confirm: {
          label: "Save",
          className: "btn-success",
          callback: function() {
            var each, j, label, labelVerts, len, nonSelectedNodeIds, ref, selectedVerts, verts2Visit;
            selectedVerts = [];
            verts2Visit = Session.get('verts2Visit');
            ref = Object.keys(verts2Visit);
            for (j = 0, len = ref.length; j < len; j++) {
              label = ref[j];
              labelVerts = _.reject(allV, function(node) {
                return node.label !== label;
              });
              selectedVerts = _.union(selectedVerts, _.sample(labelVerts, verts2Visit[label]));
            }
            currentSelectedNodeIDs = _.union(currentSelectedNodeIDs, (function() {
              var l, len1, results1;
              results1 = [];
              for (l = 0, len1 = selectedVerts.length; l < len1; l++) {
                each = selectedVerts[l];
                results1.push(each.id + "");
              }
              return results1;
            })());
            nonSelectedNodeIds = _.reject((function() {
              var l, len1, results1;
              results1 = [];
              for (l = 0, len1 = allV.length; l < len1; l++) {
                each = allV[l];
                results1.push(each.id + "");
              }
              return results1;
            })(), function(id) {
              return _.contains(currentSelectedNodeIDs, id);
            });
            allE = _.reject(allE, function(edge) {
              return _.contains(nonSelectedNodeIds, edge.inV + "") || _.contains(nonSelectedNodeIds, edge.outV + "");
            });
            return addInTheNeighbors(currentSelectedNodeIDs, currentSelectedEdgeIDs, selectedVerts, allE);
          }
        }
      }
    });
    box.find('.bootbox-body').remove();
    return Blaze.renderWithData(Template.VisitSelector, function() {
      return {
        allV: allV,
        allE: allE
      };
    }, box.find(".modal-body")[0]);
  };

  addInTheNeighbors = function(nodes2Select, edges2Select, allV, allE) {
    var ahe, ahn, e, edge, edges, j, l, len, len1, nodes, v, vert;
    ahn = allHiddenNodeIDs();
    allV = _.reject(allV, function(node) {
      return _.contains(ahn, node.id + ""); //make sure its a string2string compare
    });
    nodes = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = allV.length; j < len; j++) {
        v = allV[j];
        results1.push({
          id: String(v.id),
          label: labelForVertex(v, Session.get('keyForNodeLabel')),
          allowedToMoveX: true,
          allowedToMoveY: true,
          title: titleForElement(v),
          element: v
        });
      }
      return results1;
    })();
    window.visnetwork.nodesHandler.body.data.nodes.update(nodes);
    ahe = allHiddenEdgeIDs();
    allE = _.reject(allE, function(edge) {
      return _.contains(ahe, edge.id + ""); //make sure its a string2string compare
    });
    edges = (function() {
      var j, len, results1;
      results1 = [];
      for (j = 0, len = allE.length; j < len; j++) {
        e = allE[j];
        results1.push({
          id: String(e.id),
          label: e.label,
          from: String(e.outV),
          to: String(e.inV),
          title: titleForElement(e),
          element: e
        });
      }
      return results1;
    })();
    window.visnetwork.edgesHandler.body.data.edges.update(edges);
    for (j = 0, len = nodes.length; j < len; j++) {
      vert = nodes[j];
      nodes2Select.push(vert.id);
    }
    for (l = 0, len1 = edges.length; l < len1; l++) {
      edge = edges[l];
      edges2Select.push(edge.id);
    }
    return window.visnetwork.setSelection({
      nodes: nodes2Select,
      edges: edges2Select
    });
  };

  scriptForGeneralIngestionFindOrCreate = function() {
    return '//given arrays of json for verts and edges, generate them into the graph\n//verts2FindOrCreate = incoming binding, an map of objects of properties to use to find existing vertices, or to create them if needed, keyed by fake vertID\n/* Example:   (needs to be a full description of the vertex in case we need to create it\n[\n    {label: "Sensor", id: 0, properties:{"sensorID": [{value: "v000000ktsmkitch"}]}}\n]\n*/\n//vertsJSON = incoming binding, an array of vertex-structured objects\n//edgesJSON = incoming binding, an array of edge-structured objects\n//transactionContext = incoming binding, string declaring purpose of graph transaction (comes out in Kafka topic "graphChange")\n\nif (bindings[\'vertsJSON\'] == null) {vertsJSON = []} else {vertsJSON = bindings[\'vertsJSON\']}\nif (bindings[\'edgesJSON\'] == null) {edgesJSON = []} else {edgesJSON = bindings[\'edgesJSON\']}\nif (bindings[\'verts2FindOrCreate\'] == null) {verts2FindOrCreate = []} else {verts2FindOrCreate = bindings[\'verts2FindOrCreate\']}\nif (bindings[\'transactionContext\'] == null) {transactionContext = "unlabeled transaction"} else {transactionContext = bindings[\'transactionContext\']}\n\nvMap = [:]\nvMapFull = [:]\neMapFull = [:]\nverts2FindOrCreate.collect { json ->\n    trav = g.V().hasLabel(json.label)\n    json.properties.each { key, val ->\n        trav = trav.has(key, val[0].value)\n        }\n    results = trav.toList()\n   if (results.size == 0) {oldV = null} else {oldV = results[0]}\n    if (oldV == null){\n        //create it\n        newV = gg(transactionContext).addV(json.label).next()\n        json.properties.each { key, val ->\n            gg(transactionContext).V(newV.id()).property(key, val[0].value).next()\n            }\n    } else {\n        //reference it\n        newV = oldV\n    }\n    vMap[json.id] = newV.id()\n\n}\n\n\nvertsJSON.collect { json ->\n    newV = gg(transactionContext).addV(json.label).next()\n    vMap[json.id] = newV.id()\n    vMapFull[json.id] = newV\n    json.properties.each { key, val ->\n        gg(transactionContext).V(newV.id()).property(key, val[0].value).next()\n}}\nedgesJSON.collect { json ->\n    fromID = vMap[json.outV] ? vMap[json.outV] : json.outV\n    toID = vMap[json.inV] ? vMap[json.inV] : json.inV\n    newEdge=gg(transactionContext).V(fromID).addE(json.label).to(g.V(toID)).next()\n    eMapFull[json.id] = newEdge\n    json.properties.collect { key, val ->\n        gg(transactionContext).E(newEdge.id()).property(key, val.value).next()\n}}\n//answer the maps of old element ids to new elements\n[vMap: vMap, vertMap: vMapFull, edgeMap: eMapFull]';
  };

}).call(this);

//# sourceMappingURL=ResultsVis.js.map
